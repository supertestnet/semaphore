<!DOCTYPE html>
<html>
    <head>
        <title>Semaphore | Crowdfunding with bitcoin</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <script src="https://supertestnet.github.io/nostr-image-host/nostr_image_host.js"></script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/bolt11.js"></script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/qrcode.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/6502/sha256@main/sha256.js"></script>
        <script src="https://unpkg.com/@cmdcode/tapscript@1.4.0"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script src="https://bundle.run/bech32@2.0.0"></script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 1000px;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 0;
                width: 100%;
                background-color: lightblue;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input, textarea {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            textarea {
                height: 8rem;
            }
            .all_container {
                width: 100%;
                height: 100%;
                position: absolute;
                top: 0;
                left: 0;
                margin: auto;
            }
            .hidden {
                display: none !important;
            }
            .logo_image {
                max-width: 100%;
            }
            .navbar_container {
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100%;
                border-bottom: 1px solid black;
                background-color: white;
            }
            .navbar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                max-width: 1000px;
                margin: auto;
                height: 100px;
                padding: 1rem;
            }
            .logo_name_and_desc {
                display: flex;
                justify-content: flex-start;
                align-items: center;
            }
            .semaphore_logo {
                border: 1px solid black;
                width: 60px;
                height: 60px;
                border-radius: 50%;
                overflow: hidden;
            }
            .semaphore_name_and_desc {
                margin-left: 1rem;
            }
            .semaphore_name {
                font-family: Garamond, serif;
                font-style: italic;
                font-weight: bold;
                font-size: 200%;
            }
            .semaphore_desc {
                font-style: italic;
            }
            .login_btn {
                display: block;
                background-color: orange;
                width: 110px;
                color: white;
                font-weight: bold;
                font-family: Helvetica, sans-serif;
                padding: 0.5rem;
                float: right;
                cursor: pointer;
            }
            .below_navbar {
                position: relative;
                top: calc( 100px + 1rem );
                padding: 1rem;
                padding-top: 0;
            }
            .page_content {
                max-width: 1000px;
                margin: auto;
            }
            .countdown_div {
                text-align: center;
                margin-bottom: 1rem;
            }
            .project .project_header {
                border: 1px solid black;
                height: 200px;
                width: 100%;
                display: flex;
            }
            .project .image_and_name {
                display: flex;
                flex-direction: column;
                flex-basis: 10%;
                flex: 6;
                background-size: cover;
                background-position: 50% 50%;
                background-repeat: no-repeat;
                justify-content: flex-end;
                color: white;
            }
            .project .project_nym {
                height: 50%;
                padding: 1rem;
                display: flex;
                align-items: flex-end;
                font-size: 150%;
                background-image: linear-gradient(rgb(255,255,255,0), black);
            }
            .project .project_meta {
                background-color: purple;
                display: flex;
                flex-direction: column;
                flex-basis: 10%;
                flex: 4;
                text-align: center;
                color: white;
            }
            .project .raised_and_goal {
                display: flex;
                flex-direction: row;
                flex-basis: 100%;
                flex: 1;
                align-items: center;
            }
            .project .raised_and_goal_inner, .project .raised_and_goal_inner * {
                width: 100%;
            }
            .project .raised_div, .project .goal_div {
                display: flex;
                flex-direction: row;
                flex-basis: 100%;
                flex: 1;
            }
            .project .raised_inner {
                font-size: 150%;
            }
            .project .raised, .project .num_of_pledgers, .project .percent_funded {
                font-size: 150%;
                font-weight: bold;
            }
            .project .goal_inner, .project .num_of_pledgers_label, .project .percent_funded_label, .project .raised, .project .raised_ending {
                font-size: 90%;
            }
            .project .goal_inner span {
                font-size: 100%;
            }
            .project .num_and_percent {
                display: flex;
                align-items: center;
                height: 100%;
                border-top: 2px solid black;
                flex-direction: row;
                flex-basis: 100%;
                flex: 1;
            }
            .project .num_of_pledgers_div, .project .percent_funded_div {
                display: flex;
                flex-direction: column;
                flex-basis: 100%;
                flex: 1;
                justify-content: center;
            }
            .project .num_of_pledgers_div {
                border-right: 2px solid black;
                height: 100%;
            }
            .project .percent_funded_div {
                height: 100%;
            }
            .project .project_body {
                padding: 1rem 1rem;
                background-color: white;
                word-wrap: break-word;
            }
            .project .pledge_div {
                text-align: center;
            }
            .project .button {
                display: block;
                background-color: orange;
                width: 100%;
                max-width: calc( 400px - 2rem );
                color: white;
                font-weight: bold;
                font-family: Helvetica, sans-serif;
                padding: 0.5rem;
                float: right;
                cursor: pointer;
                margin-bottom: 1rem;
            }
            .project .revoke_button, .project .claim_button {
                clear: both;
            }
            .project .column_right {
                float: right;
                clear: both;
                max-width: calc( 400px - 2rem );
                width: 100%;
            }
            .project .column_left {
                max-width: calc( 600px - 3.5rem );
            }
            .project .comments_bottom {
                display: none;
            }
            .project .comment {
                border: 2px solid orange;
                margin-bottom: 1rem;
            }
            .project .contrib_div {
                text-align: center;
                background-color: orange;
                color: white;
                font-weight: bold;
            }
            .project .inner_comment_div {
                margin: 1rem;
                text-align: center;
            }
            .black-bg {
                width: 100%;
                position: fixed;
                top: 0;
                left: 0;
                background-color: black;
                opacity: .5;
                width: 100vw;
                height: 100vh;
            }
            .modal {
                position: fixed;
                box-sizing: border-box;
                top: 50%;
                left: 50%;
                transform: translate(-50%,-50%);
                width: 90%;
                max-width: 560px;
                background-color: white;
                border-radius: 1rem;
                padding: 20px;
                color: black;
                text-align: center;
                word-wrap: break-word;
            }
            .modal * {
                color: black;
            }
            .reversibility_button {
                padding: 0.5rem;
                color: white;
                width: 8rem;
                cursor: pointer;
                border-radius: 0.5rem;
            }
            .irreversible {
                background-color: blue;
            }
            .reversible {
                background-color: green;
            }
            .qr_code {
                max-width: 18rem;
            }
            .create_project {
                max-width: 60ch;
                margin: auto;
                background-color: #fff5d9;
                border: 1px solid black;
                padding: 1rem;
                border-radius: 1rem;
            }
            .project .comments_label {
                font-weight: bold;
                margin-top: 0;
                text-align: center;
            }
            .status {
                margin-top: 1rem;
            }
            @media screen and (max-width: 990px) {
                .semaphore_logo {
                    width: 40px;
                    height: 40px;
                }
                .semaphore_name_and_desc .semaphore_name {
                    font-size: 130%;
                }
                .semaphore_name_and_desc .semaphore_desc {
                    font-size: 60%;
                }
                .login_btn {
                    padding: 0.3rem;
                    font-size: 80%;
                    width: 80px;
                }
                .project .project_header {
                    border: 1px solid black;
                    height: 400px;
                    width: 100%;
                    display: flex;
                    flex-direction: column;
                }
                .project .image_and_name {
                    background-size: cover;
                    background-position: 50% 50%;
                    justify-content: flex-end;
                    color: white;
                }
                .project .project_meta {
                    background-color: purple;
                    text-align: center;
                    color: white;
                }
                .project .button {
                    max-width: none;
                    width: 100%;
                    float: none;
                    margin-bottom: 1rem;
                }
                .project .column_left {
                    max-width: 100%;
                    margin-bottom: 1rem;
                }
                .project .column_right {
                    display: none;
                }
                .project .comments_bottom {
                    display: block;
                }
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
        </script>
        <script>
            //fundraiser: file:///home/supertestnet/semaphore/index.html?fundraiser=nimg17ff779vkfuau77xpdy7l2wrvk62t6hr6q304qqpr6mkrn2phejg8wumn8ghj7mn0wd68yat99e3k7mgv6u6hj
            var btc_sec = nostr_image_host.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
            var btc_pub = nobleSecp256k1.getPublicKey( btc_sec, true ).substring( 2 );
            var contributor_utxos;
            var contributed_utxos = [];
            var fundraiser_addy;
            var timeloop_seconds;
            var relay = "wss://nostrue.com";
            if ( $_GET[ "relay" ] ) relay = $_GET[ "relay" ];
            var socket;
            var project;
            var btc_net = "mempool.space";
            var mainnet_or_testnet = "mainnet";
            if ( $_GET[ "network" ] == "testnet" ) {
                var btc_net = "mutinynet.com";
                var mainnet_or_testnet = "testnet";
            }
            var used_txid_and_vouts = [];
            var upload_data = [];
            var downloaded_sigs = {}
            var lastblock;
            var levels = [];
            var funds_spent_cooperatively = false;
            var lightning_works;
            var hexToBase64 = hex => btoa( hex.match( /\w{2}/g ).map( a => String.fromCharCode( parseInt( a, 16 ) ) ).join( "" ) );
            var finishUpload = async ( socket, main_sigs, extra_sigs_id, contributor_key, fundraiser_key, txid, vout, comment, recovery, recovery_fee, privKey, pubKey ) => {
                var note = JSON.stringify({
                    fundraiser_id: $_GET[ "fundraiser" ],
                    is_lightning: false,
                    main_sigs,
                    extra_sigs_id,
                    contributor_key,
                    txid,
                    vout,
                    public_comment: comment,
                    recovery,
                    recovery_fee,
                });
                var event = {
                    "content"    : note,
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"       : 62116,
                    "tags"       : [ [ "p", fundraiser_key ] ],
                    "pubkey"     : pubKey,
                }
                var signedEvent = await nostr_image_host.getSignedEvent( event, privKey );
                socket.send( JSON.stringify([ "EVENT", signedEvent ]) );
                await nostr_image_host.waitSomeSeconds( 2 );
                socket.close();
                var html = `<p>Success! Your contribution has been recorded</p>`;
                checkForUtxos();
                showModal( html );
            }
            function getData( url ) {
                return new Promise( async function( resolve, reject ) {
                    function inner_get( url ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.open( "GET", url, true );
                        xhttp.send();
                        return xhttp;
                    }
                    var data = inner_get( url );
                    data.onerror = function( e ) {
                        resolve( "error" );
                    }
                    async function isResponseReady() {
                        return new Promise( function( resolve2, reject ) {
                            if ( !data.responseText || data.readyState != 4 ) {
                                setTimeout( async function() {
                                    var msg = await isResponseReady();
                                    resolve2( msg );
                                }, 1 );
                            } else {
                                resolve2( data.responseText );
                            }
                        });
                    }
                    var returnable = await isResponseReady();
                    resolve( returnable );
                });
            }
            var satsToBitcoin = sats => {
                var btc = String( sats ).padStart( 8, "0" ).slice( 0,-8 ) + "." + String( sats ).padStart( 8, "0" ).slice( -8 );
                if ( btc.endsWith( "00000" ) ) {
                    btc = btc.substring( 0, btc.length - 5 );
                    var i; for ( i=0; i<5; i++ ) {
                        if ( btc.endsWith( "0" ) ) btc = btc.substring( 0, btc.length - 1 );
                    }
                    if ( btc.endsWith( "." ) ) btc = btc.substring( 0, btc.length - 1 );
                }
                return btc;
            }
            var loadProject = async project => {
                $( '.project' ).innerHTML = '';
                var html = `
                    <div class="user_project">
                        <div class="countdown_div">loading...</div>
                        <div class="project_header hidden">
                            <div class="image_and_name">
                                <div class="project_nym"></div>
                            </div>
                            <div class="project_meta">
                                <div class="raised_and_goal">
                                    <div class="raised_and_goal_inner">
                                        <div class="raised_div">
                                            <div class="raised_inner">
                                                <span class="raised">0</span> <span class="raised_ending"></span>
                                            </div>
                                        </div>
                                        <div class="goal_div">
                                            <div class="goal_inner">
                                                PLEDGED OF <span class="goal"></span> <span class="goal_ending"></span> GOAL
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="num_and_percent">
                                    <div class="num_of_pledgers_div"><div class="num_of_pledgers">0</div><div class="num_of_pledgers_label">PLEDGERS</div></div>
                                    <div class="percent_funded_div"><div class="percent_funded">0%</div><div class="percent_funded_label">FUNDED</div></div>
                                </div>
                            </div>
                        </div>
                        <div class="project_body hidden">
                            <div class="pledge_div"><button class="button pledge_button">PLEDGE</button></div>
                            <div class="revoke_div"><button class="button revoke_button hidden">REVOKE</button></div>
                            <div class="revoke_div"><button class="button claim_button hidden">CLAIM</button></div>
                            <div class="column_right"><p class="comments_label hidden">Comments</p></div>
                            <div class="column_left"></div>
                            <div class="comments_bottom"><p class="comments_label hidden">Comments</p></div>
                            <div style="clear: both;"></div>
                        </div>
                    </div>
                `;
                var div = document.createElement( "div" );
                div.innerHTML = html;
                div = div.firstElementChild;
                $( '.project' ).append( div );
                if ( btc_pub == project.project_key ) $( '.claim_button' ).classList.remove( "hidden" );
                var current_blockheight = await getBlockheight( "" );
                var blocks_left = project.project_end - current_blockheight;
                var time_left = blocks_left * 600;
                if ( !timeloop_seconds ) timeloop( time_left );
                $( '.project .project_nym' ).innerText = project.project_nym;
                var b64 = project.project_pic;
                $( ".image_and_name" ).setAttribute( "data-bg", b64 );
                $( ".image_and_name" ).style.backgroundImage = `url( '${b64}' )`;
                var goal = project.project_gol;
                var goal_ending = "SATS";
                if ( goal > 1000000 ) {
                    goal = satsToBitcoin( goal );
                    goal_ending = "BTC";
                } else {
                    goal = goal.toLocaleString();
                }
                $( ".goal" ).innerText = goal;
                $( ".goal_ending" ).innerText = goal_ending;
                var raised = Number( $( ".raised" ).innerText );
                $( ".column_left" ).innerText = project.project_dsc;
                var script = [ 0, btc_pub, 'OP_CHECKSIGADD', project.project_key, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ];
                var tapleaf = tapscript.Tap.encodeScript( script );
                var [ tseckey_keypath ] = tapscript.Tap.getSecKey( btc_sec, { tree: [script].map( s => tapscript.Tap.encodeScript( s ) ) } );
                // var [ tseckey_script_path ] = tapscript.Tap.getSecKey( btc_sec, { tree: [script].map( s => tapscript.Tap.encodeScript( s ) ), target: tapleaf });
                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey( btc_pub, { target: tapleaf });
                var address = tapscript.Address.p2tr.fromPubKey( tpubkey, mainnet_or_testnet );
                $( '.pledge_button' ).onclick = async () => {
                    var main_sigs = [];
                    var extra_sigs = [];
                    sessionStorage.removeItem( "modal_cleared" );
                    sessionStorage.removeItem( "reversible" );
                    if ( funds_spent_cooperatively || current_blockheight >= project.project_end ) showIrreversible();
                    else show_pledge_options();
                    await getNote( "modal_cleared" );
                    if ( !( "reversible" in sessionStorage ) ) return;
                    sessionStorage.removeItem( "reversible" );
                    sessionStorage.removeItem( "modal_cleared" );
                    sessionStorage.removeItem( "recovery" );
                    showModal( `
                        <p style="font-weight: bold;">Enter a bitcoin address for a refund if the fundraiser does not reach its goal</p>
                        <p><input style="max-width: 90%" class="recovery_address"></p>
                        <p><button class="submit_recovery_address" onclick="sessionStorage[ 'recovery' ] = $( '.recovery_address' ).value;sessionStorage[ 'modal_cleared' ] = true;">Submit</button></p>
                    `, true );
                    await getNote( "modal_cleared" );
                    var recovery = await getNote( "recovery" );
                    if ( !isValidAddress( recovery ) ) return showModal( `Invalid contribution due to bad recovery address. Please try again` );
                    var backup_file_contents = {
                        privkey: btc_sec,
                        fundraiser_id: $_GET[ "fundraiser" ],
                    }
                    var fileName = `semaphore_contributor_${$_GET[ "fundraiser" ]}_backup.json`;
                    var html = `<p>An automatic refund may occur if the fundraiser does not reach its goal. However, automatic refunds are not guaranteed to work. Therefore, it is paramount that you download and store <span style="color: blue; text-decoration: underline; cursor: pointer;" onclick='saveData( ${JSON.stringify( backup_file_contents )}, "${fileName}" );'>your backup file</span> so that you can upload it later using the "Log in" button and broadcast your own refund if necessary. Please please please, do not proceed without backing up your data, or you are at risk of fund loss. If for any reason Semaphore stops working, you will need this file to recover your funds.</p><p><button onclick="$( '.x_modal' ).click();">I've backed up my data, continue</button></p>`;
                    sessionStorage.removeItem( "modal_cleared" );
                    showModal( html, true );
                    await getNote( "modal_cleared" );
                    var url = "bitcoin:" + address;
                    var a = document.createElement( "a" );
                    a.href = url;
                    a.target = "_blank";
                    a.append( createQR( url.toUpperCase() ) );
                    var prep_div = document.createElement( "div" );
                    prep_div.innerHTML = `<p>Please send your contribution here</p>`;
                    prep_div.append( a );
                    var div_html = prep_div.innerHTML + `<p>${address}</p>`;
                    showModal( div_html );
                    var utxos = await getData( `https://${btc_net}/api/address/${address}/utxo` );
                    utxos = JSON.parse( utxos );
                    var simplified_utxos = [];
                    utxos.forEach( item => simplified_utxos.push( `${item[ "txid" ]}:${item[ "vout" ]}` ) );
                    var new_utxo = await utxoloop( address, simplified_utxos );
                    sessionStorage.removeItem( "modal_cleared" );
                    sessionStorage.removeItem( "comment" );
                    showModal( `
                        <p style="font-weight: bold;">Pledge detected! Enter a public comment to send with it (optional)</p>
                        <p><input style="max-width: 90%" class="modal_comment"></p>
                        <p>Chars left: <span class="modal_comment_chars_left">140</span></p>
                        <p><button class="submit_modal_comment">Submit</button></p>
                    `, true );
                    $( '.submit_modal_comment' ).onclick = () => {
                        sessionStorage[ 'comment' ] = $( '.modal_comment' ).value;
                        sessionStorage[ 'modal_cleared' ] = true;
                        showModal( `
                            <p>Uploading signatures, please wait</p>
                            <h2>Progress bar <span id='goal' style='font-size: .8em; font-weight: normal;'></span></h2>
                            <div class='progressOutline' style='height: 2em; border: 1px solid grey; border-radius: 25px; overflow: hidden;'>
                                <div class='progressBar' style='height: 2em; background-color: #61eb34; width: 0%; transition: width 1s;'></div>
                            </div>
                        ` );
                    }
                    $( '.modal_comment' ).onchange = () => {
                        var text = $( '.modal_comment' ).value;
                        var limit = 140;
                        var length = text.length;
                        if ( limit - length < 0 ) return $( '.modal_comment' ).value = text.substring( 0, limit );
                        $( '.modal_comment_chars_left' ).innerText = `${limit - length}`;
                    }
                    $( '.modal_comment' ).onkeyup = () => {
                        var text = $( '.modal_comment' ).value;
                        var limit = 140;
                        var length = text.length;
                        if ( limit - length < 0 ) return $( '.modal_comment' ).value = text.substring( 0, limit );
                        $( '.modal_comment_chars_left' ).innerText = `${limit - length}`;
                    }
                    await getNote( "modal_cleared" );
                    var comment = await getNote( "comment" );
                    sessionStorage.removeItem( "comment" );
                    var txid_vout_amt = new_utxo.split( ":" );
                    var txid = txid_vout_amt[ 0 ];
                    var vout = Number( txid_vout_amt[ 1 ] );
                    var amt = Number( txid_vout_amt[ 2 ] );
                    var fee_rates = await getThreeFeeRates( "" );
                    var sats_per_byte = fee_rates[ 1 ];
                    //I assume the txsize begins as 4 bytes for the version number, 4
                    //bytes for the locktime, 1 byte for the size of the witness script,
                    //1 byte for the size of the locking script, 1 byte for the size
                    //of the pubkey in the locking script, and 1 byte for OP_0 or OP_1
                    //preceding the output script
                    var txsize = 12;
                    //I calculate that inputs add 65 bytes for the sig, 35 bytes for
                    //the txid, and 5 bytes for the vout (remembering that each one
                    //is preceded by a byte that indicates how long that string is)
                    txsize = txsize + 65 + 33 + 5;
                    //I calculate that outputs add 41 bytes apiece by
                    //assuming the average scriptpubkey is 33 bytes
                    //and assuming amounts are denoted in 8 bytes
                    txsize = txsize + 41;
                    var recovery_fee = txsize * sats_per_byte;
                    var recovery_txdata = tapscript.Tx.create({
                        vin: [{
                            txid: txid,
                            vout: vout,
                            sequence: 0xfffffffd,
                            prevout: {
                                value: amt,
                                scriptPubKey: tapscript.Address.toScriptPubKey( address ),
                            },
                        }],
                        vout: [{
                            value: amt - recovery_fee,
                            scriptPubKey: tapscript.Address.toScriptPubKey( recovery ),
                        }],
                        locktime: project.project_end + 144,
                    });
                    var recovery_sig = tapscript.Signer.taproot.sign( tseckey_keypath, recovery_txdata, 0 ).hex;
                    main_sigs.push( recovery_sig );
                    var i; for ( i=0; i<901; i++ ) {
                        var ten_percent = Math.floor( ( project.project_gol * .01 ) );
                        var extra = ten_percent * i;
                        var goal_amt = project.project_gol + extra;
                        var contribution_txdata = tapscript.Tx.create({
                            vin: [{
                                txid: txid,
                                vout: vout,
                                prevout: {
                                    value: amt,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( address ),
                                },
                            }],
                            vout: [{
                                value: goal_amt,
                                scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                            }],
                        });
                        var contribution_sig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, 0, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                        if ( !i ) main_sigs.push( contribution_sig );
                        else extra_sigs.push( contribution_sig );
                    }
                    var b64 = hexToBase64( extra_sigs.join( "" ) );
                    socket = new WebSocket( relay );
                    socket.addEventListener('open', async function( e ) {
                        var array = b64.match(/.{1,4000}/g);
                        var privKey = nostr_image_host.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                        var pubKey = nobleSecp256k1.getPublicKey( privKey, true ).substring( 2 );
                        var i; for ( i=0; i<array.length; i++ ) {
                            var note = array[ i ];
                            var part = i + 1;
                            var whole = array.length;
                            var id = await nostr_image_host.sendNoteAndReturnId( note, part, whole, socket, privKey, pubKey );
                            var nimg = nostr_image_host.hexToBech32( "nimg", id + nostr_image_host.textToHex( relay ) );
                            var percent = Number( ( ( part / whole ) * 100 ).toFixed( 2 ) );
                            if ( $( '.progressBar' ) ) $( '.progressBar' ).style.width = String( percent ) + "%";
                            if ( percent == 100 ) finishUpload( socket, main_sigs, nimg, btc_pub, project.project_key, txid, vout, comment, recovery, recovery_fee, privKey, pubKey );
                            await nostr_image_host.waitSomeSeconds( 2 );
                        }
                    });
                }
                $( '.revoke_button' ).onclick = async () => {
                    var fee_options = await getThreeFeeRates( "" );
                    sessionStorage.removeItem( "modal_cleared" );
                    sessionStorage.removeItem( "destino" );
                    showModal( `<p>Please enter a bitcoin address where you want to recover your pledge to.</p><p><input class="modal_destino" style="max-width: 90%;"></p><p><button class="modal_submit_destino" onclick="sessionStorage.destino = $( '.modal_destino' ).value;sessionStorage.modal_cleared = true;">Submit</button></p>`, true );
                    await getNote( "modal_cleared" );
                    var destino = sessionStorage[ "destino" ];
                    if ( !destino ) return showModal( "You entered an invalid address. Please try again." );
                    sessionStorage.removeItem( "destino" );
                    sessionStorage.removeItem( "modal_cleared" );
                    sessionStorage.removeItem( "destino" );
                    showModal( `<p>Please enter a fee rate as a number. Specifically, the number of sats per byte you want to pay. The minimum rate is ${fee_options[ 0 ]}, the average rate is ${fee_options[ 1 ]}, and the urgent rate is ${fee_options[ 2 ]}.</p><p><input class="modal_sats_per_byte" style="max-width: 90%;"></p><p><button class="modal_submit_sats_per_byte" onclick="sessionStorage.sats_per_byte = $( '.modal_sats_per_byte' ).value;sessionStorage.modal_cleared = true;">Submit</button></p>`, true );
                    $( '.x_modal' ).classList.add( "hidden" );
                    await getNote( "modal_cleared" );
                    sessionStorage.removeItem( "modal_cleared" );
                    modalVanish();
                    $( '.x_modal' ).classList.remove( "hidden" );
                    var sats_per_byte = Number( sessionStorage[ "sats_per_byte" ] );
                    sessionStorage.removeItem( "sats_per_byte" );
                    if ( !sats_per_byte ) return showModal( "You entered an invalid fee rate. You must enter a number greater than 0, such as 5, 10, or 25. Please try again." );
                    spendCoins( destino, sats_per_byte );
                }
                $( '.claim_button' ).onclick = async () => {
                    showModal( `<p>loading...</p>` );
                    var inputs = [];
                    var amt_in_reversible_pledges = 0;
                    contributed_utxos.forEach( item => amt_in_reversible_pledges = amt_in_reversible_pledges + item[ "value" ] );
                    var total = $( '.raised' ).innerText.replaceAll( ",", "" );
                    if ( total.includes( "." ) ) {
                        var num_of_digits_after_period = total.substring( total.indexOf( "." ) + 1 ).length;
                        var string_of_zeros = "";
                        var i; for ( i=0; i<8 - num_of_digits_after_period; i++ ) string_of_zeros = string_of_zeros + "0";
                        total = total.replaceAll( ".", "" );
                        total = total + string_of_zeros;
                    }
                    total = Number( total );
                    if ( !contributed_utxos.length && total && funds_spent_cooperatively ) return showModal( `There are no new contributions for you to claim` );
                    if ( !contributed_utxos.length && total && !funds_spent_cooperatively && !amt_in_reversible_pledges ) return showModal( `<p>All the money you've received was sent directly to your bitcoin address at ${project.project_add}</p><p>Consequently, there is no need to claim it, it is already in your wallet</p>` );
                    if ( !contributed_utxos.length ) return showModal( `There are no contributions for you to claim` );
                    // the following three lines are for testing the various scenarios
                    // amt_in_reversible_pledges = 20_000;
                    // total = 20_000;
                    // project.project_gol = 10_000;
                    await prepLevels();
                    var next_level;
                    levels.every( ( level_num, index ) => {
                        if ( level_num > amt_in_reversible_pledges ) {next_level = index;return}
                        return true;
                    });
                    if ( next_level > -1 ) var current_level = next_level - 1;
                    else {
                        var current_level = levels.length - 1;
                        next_level = levels.length - 1;
                    }
                    if ( current_level < 0 ) current_level = 0;
                    var fee_rates = await getThreeFeeRates( "" );
                    var sats_per_byte = fee_rates[ 1 ];
                    //I assume the txsize begins as 4 bytes for the version number, 4
                    //bytes for the locktime, 1 byte for the size of the witness script,
                    //1 byte for the size of the locking script, 1 byte for the size
                    //of the pubkey in the locking script, and 1 byte for OP_0 or OP_1
                    //preceding the output script
                    var txsize = 12;
                    //I calculate that inputs add 65 bytes for the first sig, 64 bytes
                    //for the second sig, 32 bytes for the txid, 4 bytes for the vout,
                    //64 bytes for the two x-only pubkeys in the script, 7 bytes for
                    //the various opcodes in the script, and 33 bytes for the cblock
                    contributed_utxos.forEach( item => txsize = txsize + 65 + 64 + 32 + 4 + 64 + 7 + 33 );
                    //I calculate that outputs add 41 bytes apiece by
                    //assuming the average scriptpubkey is 33 bytes
                    //and assuming amounts are denoted in 8 bytes
                    txsize = txsize + 41;
                    //assume an extra input since they have to deposit part
                    //of their irreversible pledges to reach their goal
                    txsize_with_extra_input = txsize + 64 + 32 + 4;
                    var mining_fee_with_no_extra_input = txsize * sats_per_byte;
                    var mining_fee_with_extra_input = txsize_with_extra_input * sats_per_byte;
                    if ( mining_fee_with_no_extra_input < 172 ) mining_fee_with_no_extra_input = 172;
                    if ( mining_fee_with_extra_input < 172 ) mining_fee_with_extra_input = 172;
                    var some_money_in_irreversible = total > amt_in_reversible_pledges;

                    var total_friendly = total;
                    var total_ending = "sats";
                    if ( total_friendly > 1000000 ) {
                        total_friendly = satsToBitcoin( total_friendly );
                        total_ending = "btc";
                    } else {
                        total_friendly = total_friendly.toLocaleString();
                    }

                    if ( current_level > 0 ) {
                        var prev_level_friendly = levels[ current_level - 1 ];
                        var prev_level_ending = "sats";
                        if ( prev_level_friendly > 1000000 ) {
                            prev_level_friendly = satsToBitcoin( prev_level_friendly );
                            prev_level_ending = "btc";
                        } else {
                            prev_level_friendly = prev_level_friendly.toLocaleString();
                        }
                    }

                    var current_level_friendly = levels[ current_level ];
                    var current_level_ending = "sats";
                    if ( current_level_friendly > 1000000 ) {
                        current_level_friendly = satsToBitcoin( current_level_friendly );
                        current_level_ending = "btc";
                    } else {
                        current_level_friendly = current_level_friendly.toLocaleString();
                    }

                    var next_level_friendly = levels[ next_level ];
                    var next_level_ending = "sats";
                    if ( next_level_friendly > 1000000 ) {
                        next_level_friendly = satsToBitcoin( next_level_friendly );
                        next_level_ending = "btc";
                    } else {
                        next_level_friendly = next_level_friendly.toLocaleString();
                    }

                    goal_minus_total = levels[ next_level ] - total;
                    var goal_minus_total_friendly = goal_minus_total;
                    var goal_minus_total_ending = "sats";
                    if ( goal_minus_total_friendly > 1000000 ) {
                        goal_minus_total_friendly = satsToBitcoin( goal_minus_total_friendly );
                        goal_minus_total_ending = "btc";
                    } else {
                        goal_minus_total_friendly = goal_minus_total_friendly.toLocaleString();
                    }

                    var amt_in_reversible_pledges_friendly = amt_in_reversible_pledges;
                    var amt_in_reversible_pledges_ending = "sats";
                    if ( amt_in_reversible_pledges_friendly > 1000000 ) {
                        amt_in_reversible_pledges_friendly = satsToBitcoin( amt_in_reversible_pledges_friendly );
                        amt_in_reversible_pledges_ending = "btc";
                    } else {
                        amt_in_reversible_pledges_friendly = amt_in_reversible_pledges_friendly.toLocaleString();
                    }

                    var remainder = total - amt_in_reversible_pledges;
                    var remainder_friendly = remainder;
                    var remainder_ending = "sats";
                    if ( remainder_friendly > 1000000 ) {
                        remainder_friendly = satsToBitcoin( remainder_friendly );
                        remainder_ending = "btc";
                    } else {
                        remainder_friendly = remainder_friendly.toLocaleString();
                    }

                    goal_minus_reversible = levels[ next_level ] - amt_in_reversible_pledges;
                    var goal_minus_reversible_friendly = goal_minus_reversible;
                    var goal_minus_reversible_ending = "sats";
                    if ( goal_minus_reversible_friendly > 1000000 ) {
                        goal_minus_reversible_friendly = satsToBitcoin( goal_minus_reversible_friendly );
                        goal_minus_reversible_ending = "btc";
                    } else {
                        goal_minus_reversible_friendly = goal_minus_reversible_friendly.toLocaleString();
                    }

                    var deposit_for_current_level = ( levels[ current_level ] - amt_in_reversible_pledges ) + mining_fee_with_extra_input;
                    if ( deposit_for_current_level < 546 ) deposit_for_current_level = 546;
                    var deposit_for_current_level_friendly = deposit_for_current_level;
                    var deposit_for_current_level_ending = "sats";
                    if ( deposit_for_current_level_friendly > 1000000 ) {
                        deposit_for_current_level_friendly = satsToBitcoin( deposit_for_current_level_friendly );
                        deposit_for_current_level_ending = "btc";
                    } else {
                        deposit_for_current_level_friendly = deposit_for_current_level_friendly.toLocaleString();
                    }

                    var deposit_for_next_level = ( levels[ next_level ] - amt_in_reversible_pledges ) + mining_fee_with_extra_input;
                    if ( deposit_for_next_level < 546 ) deposit_for_next_level = 546;
                    var deposit_for_next_level_friendly = deposit_for_next_level;
                    var deposit_for_next_level_ending = "sats";
                    if ( deposit_for_next_level_friendly > 1000000 ) {
                        deposit_for_next_level_friendly = satsToBitcoin( deposit_for_next_level_friendly );
                        deposit_for_next_level_ending = "btc";
                    } else {
                        deposit_for_next_level_friendly = deposit_for_next_level_friendly.toLocaleString();
                    }

                    var extra = amt_in_reversible_pledges - levels[ current_level ];
                    var extra_friendly = extra;
                    var extra_ending = "sats";
                    if ( extra_friendly > 1000000 ) {
                        extra_friendly = satsToBitcoin( extra_friendly );
                        extra_ending = "btc";
                    } else {
                        extra_friendly = extra_friendly.toLocaleString();
                    }

                    var overpayment = extra - mining_fee_with_no_extra_input;
                    var overpayment_friendly = overpayment;
                    var overpayment_ending = "sats";
                    if ( overpayment_friendly > 1000000 ) {
                        overpayment_friendly = satsToBitcoin( overpayment_friendly );
                        overpayment_ending = "btc";
                    } else {
                        overpayment_friendly = overpayment_friendly.toLocaleString();
                    }

                    var remainder_if_exeeding_10x = amt_in_reversible_pledges - levels[ current_level ];
                    var remainder_if_exeeding_10x_friendly = remainder_if_exeeding_10x;
                    var remainder_if_exeeding_10x_ending = "sats";
                    if ( remainder_if_exeeding_10x_friendly > 1000000 ) {
                        remainder_if_exeeding_10x_friendly = satsToBitcoin( remainder_if_exeeding_10x_friendly );
                        remainder_if_exeeding_10x_ending = "btc";
                    } else {
                        remainder_if_exeeding_10x_friendly = remainder_if_exeeding_10x_friendly.toLocaleString();
                    }

                    if ( current_level > 0 ) {
                        var more_extra = amt_in_reversible_pledges - levels[ current_level - 1 ];
                        var more_extra_friendly = more_extra;
                        var more_extra_ending = "sats";
                        if ( more_extra_friendly > 1000000 ) {
                            more_extra_friendly = satsToBitcoin( more_extra_friendly );
                            more_extra_ending = "btc";
                        } else {
                            more_extra_friendly = more_extra_friendly.toLocaleString();
                        }

                        var more_overpayment = more_extra - mining_fee_with_no_extra_input;
                        var more_overpayment_friendly = more_overpayment;
                        var more_overpayment_ending = "sats";
                        if ( more_overpayment_friendly > 1000000 ) {
                            more_overpayment_friendly = satsToBitcoin( more_overpayment_friendly );
                            more_overpayment_ending = "btc";
                        } else {
                            more_overpayment_friendly = more_overpayment_friendly.toLocaleString();
                        }
                    }

                    var msg = `<p>Be patient! You need ${goal_minus_total_friendly} more ${goal_minus_total_ending} before you can claim your funds</p>`;

                    if ( total < levels[ current_level ] && current_level == 0 ) return showModal( msg );

                    var we_are_in_scen_9;
                    var we_are_in_scen_10;

                    var amount_i_can_withdraw_if_i_must_step_down;
                    var index_of_amount_i_can_withdraw_if_i_must_step_down = -1;

                    if ( more_extra < mining_fee_with_no_extra_input ) {
                        //console.log( `the amount of fees I would pay if I used my reversible contributions of ${amt_in_reversible_pledges_friendly} ${amt_in_reversible_pledges_ending} to withdraw ${prev_level_friendly} ${prev_level_ending} is ${more_extra} but it needs to be at least ${mining_fee_with_no_extra_input} sats.` );
                        var reversed_levels = JSON.parse( JSON.stringify( levels ) ).reverse();
                        var i_must_get_lower_than = amt_in_reversible_pledges - mining_fee_with_no_extra_input;
                        //console.log( `I must withdraw the first amount lower than`, i_must_get_lower_than );
                        reversed_levels.every( item => {
                            if ( item < i_must_get_lower_than ) {
                                amount_i_can_withdraw_if_i_must_step_down = item;
                                return;
                            }
                            return true;
                        });
                        if ( amount_i_can_withdraw_if_i_must_step_down ) index_of_amount_i_can_withdraw_if_i_must_step_down = levels.indexOf( amount_i_can_withdraw_if_i_must_step_down );
                        if ( index_of_amount_i_can_withdraw_if_i_must_step_down < 0 && some_money_in_irreversible ) we_are_in_scen_9 = true;
                        if ( index_of_amount_i_can_withdraw_if_i_must_step_down < 0 && !some_money_in_irreversible ) we_are_in_scen_10 = true;
                    } else {
                        amount_i_can_withdraw_if_i_must_step_down = levels[ current_level - 1 ];
                        index_of_amount_i_can_withdraw_if_i_must_step_down = levels.indexOf( amount_i_can_withdraw_if_i_must_step_down );
                    }

                    if ( index_of_amount_i_can_withdraw_if_i_must_step_down > -1 && index_of_amount_i_can_withdraw_if_i_must_step_down != current_level - 1 ) {
                        var more_extra = amt_in_reversible_pledges - levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ];
                        var more_extra_friendly = more_extra;
                        var more_extra_ending = "sats";
                        if ( more_extra_friendly > 1000000 ) {
                            more_extra_friendly = satsToBitcoin( more_extra_friendly );
                            more_extra_ending = "btc";
                        } else {
                            more_extra_friendly = more_extra_friendly.toLocaleString();
                        }

                        var more_overpayment = more_extra - mining_fee_with_no_extra_input;
                        var more_overpayment_friendly = more_overpayment;
                        var more_overpayment_ending = "sats";
                        if ( more_overpayment_friendly > 1000000 ) {
                            more_overpayment_friendly = satsToBitcoin( more_overpayment_friendly );
                            more_overpayment_ending = "btc";
                        } else {
                            more_overpayment_friendly = more_overpayment_friendly.toLocaleString();
                        }
                    }

                    if ( amount_i_can_withdraw_if_i_must_step_down ) {
                        var amount_i_can_withdraw_if_i_must_step_down_friendly = amount_i_can_withdraw_if_i_must_step_down;
                        var amount_i_can_withdraw_if_i_must_step_down_ending = "sats";
                        if ( amount_i_can_withdraw_if_i_must_step_down_friendly > 1000000 ) {
                            amount_i_can_withdraw_if_i_must_step_down_friendly = satsToBitcoin( amount_i_can_withdraw_if_i_must_step_down_friendly );
                            amount_i_can_withdraw_if_i_must_step_down_ending = "btc";
                        } else {
                            amount_i_can_withdraw_if_i_must_step_down_friendly = amount_i_can_withdraw_if_i_must_step_down_friendly.toLocaleString();
                        }
                    }

                    // There are 4 variables:
                        //(1) can be "enough in reversible for level X without fees" OR "enough in reversible for level X with fees" DOUBLE BUT there is some money in irreversible
                        //(2) can be "X == 0" or "X > 0"
                        //(3) can be "X == levels.length - 1" or "X < levels.length - 1"
                        //(4) can be "there is some money in irreversible" OR "there is NO money in irreversible"

                    // You might think these would lead to 2^4 = 16 combinations: 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111

                    // However, 2 & 3 have some overlap. If 2 is 1 ("X > 0") 3 could be 0 or 1, but if 2 is 0 3 is definitely 1.
                    // Similarly, if 3 is 1 ("X < levels.length - 1") 2 could be 0 or 1, but if 3 is 0 2 is definitely 1. Therefore, the
                    // following items are impossible: 0000, 0001, 1000, 1001. So there are only 12 possibilities:

                    // 0010, 0011, 0100, 0101, 0110, 0111, 1010, 1011, 1100, 1101, 1110, 1111

                    // here are the items I actually coded:

                    // 1100, 1101, 1010, 1110, 1011, 1111, 0110, 0111, 0100, 0101, 0010, 0011

                    // which, being rearranged, is:

                    // 0010, 0011, 0100, 0101, 0110, 0111, 1010, 1011, 1100, 1101, 1110, 1111

                    // So all my bases are covered :D

                    // Here are the scenarios I have to account for:

                    // scen_1 = Enough in reversible for level X + fees (and there is an X + 1) AND there is some money in irreversible (1000 & 1100) <-- the first of those is impossible so it is really just 1100
                    //     -- two options: (1) contribute enough to pay for level X + 1 + fees (2) pay for level X + fees (and possibly overpay fees)
                    var scen_1 = ( amt_in_reversible_pledges >= levels[ current_level ] + mining_fee_with_no_extra_input && current_level < levels.length - 1 && some_money_in_irreversible && !we_are_in_scen_9 && !we_are_in_scen_10 );

                    if ( scen_1 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 211_000 total: 221_000
                        // console.log( "scenario 1: amt_in_reversible_pledges", 680_000_000, "and total", 690_000_000 );
                        var utxos_to_block = [];
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            var input = {
                                txid: item[ "txid" ],
                                vout: item[ "vout" ],
                                prevout: {
                                    value: item[ "value" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                                }
                            }
                            if ( `num_${levels[ current_level ]}` in item[ "levels_with_valid_sig" ] ) {
                                var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ current_level ]}` ];
                                input.witness = [ sig ];
                                inputs.push( input );
                            }
                            else {
                                utxos_to_block.push( i );
                                continue;
                            }
                        }
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            if ( utxos_to_block.includes( index ) ) continue;
                            var contribution_txdata = tapscript.Tx.create({
                                vin: inputs,
                                vout: [{
                                    value: levels[ current_level ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                                }],
                            });
                            var tapleaf = item[ "tapleaf" ];
                            var script = item[ "script" ];
                            var cblock = item[ "cblock" ];
                            var their_key = item[ "contributor_key" ];
                            var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                            var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                            var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                            var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                            if ( !isValid ) {
                                contribution_txdata.vin.splice( i, 1 );
                                continue;
                            }
                            contribution_txdata.vin[ index ].witness.unshift( mysig );
                            contribution_txdata.vin[ index ].witness.push( script, cblock );
                            // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                        }
                        var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                        // console.log( txhex );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. ${amt_in_reversible_pledges_friendly} ${amt_in_reversible_pledges_ending} of that is in smart contracts and the remainder (${remainder_friendly} ${remainder_ending}) was sent to you directly. Given that you can only withdraw in increments of 1% above your goal, you have two options to withdraw your funds (btw both of the following options account for mining fees): you can withdraw ${next_level_friendly} ${next_level_ending} by contributing ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending} to your own fundraiser, or, if that doesn't seem like a good option to you, you can pay a fee of ${extra_friendly} ${extra_ending}. That will give you enough to withdraw ${current_level_friendly} ${current_level_ending}, but you'll be overpaying your mining fee by ${overpayment_friendly} ${overpayment_ending}.</p><p>What do you want to do?</p><p><button onclick="specialDeposit( ${deposit_for_next_level}, ${next_level} )">Deposit ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending}</button></p><p><button onclick="broadcastAndShowModal( '${txhex}' );">Withdraw now</button></p>` );
                    }

                    // scen_2 = Enough in reversible for level X + fees (and there is an X + 1) AND there is NO money in irreversible (1001 & 1101) <-- the first of those is impossible so it is really just 1101
                    //     -- two options: (1) contribute enough to pay for level X + 1 + fees (2) pay for level X + fees (and possibly overpay fees)
                    var scen_2 = ( amt_in_reversible_pledges >= levels[ current_level ] + mining_fee_with_no_extra_input && current_level < levels.length - 1 && !some_money_in_irreversible && !we_are_in_scen_9 && !we_are_in_scen_10 );

                    if ( scen_2 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 221_000 total: 221_000
                        console.log( "scenario 2: amt_in_reversible_pledges", 680_000_000, "and total", 680_000_000 );
                        var utxos_to_block = [];
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            var input = {
                                txid: item[ "txid" ],
                                vout: item[ "vout" ],
                                prevout: {
                                    value: item[ "value" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                                }
                            }
                            if ( `num_${levels[ current_level ]}` in item[ "levels_with_valid_sig" ] ) {
                                var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ current_level ]}` ];
                                input.witness = [ sig ];
                                inputs.push( input );
                            }
                            else {
                                utxos_to_block.push( i );
                                continue;
                            }
                        }
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            if ( utxos_to_block.includes( index ) ) continue;
                            var contribution_txdata = tapscript.Tx.create({
                                vin: inputs,
                                vout: [{
                                    value: levels[ current_level ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                                }],
                            });
                            var tapleaf = item[ "tapleaf" ];
                            var script = item[ "script" ];
                            var cblock = item[ "cblock" ];
                            var their_key = item[ "contributor_key" ];
                            var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                            var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                            var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                            var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                            if ( !isValid ) {
                                contribution_txdata.vin.splice( i, 1 );
                                continue;
                            }
                            contribution_txdata.vin[ index ].witness.unshift( mysig );
                            contribution_txdata.vin[ index ].witness.push( script, cblock );
                            // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                        }
                        var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                        // console.log( txhex );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. Given that you can only withdraw in increments of 1% above your goal, you have two options to withdraw your funds (btw both of the following options account for mining fees): you can withdraw ${next_level_friendly} ${next_level_ending} by contributing ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending} to your own fundraiser, or, if that doesn't seem like a good option to you, you can pay a fee of ${extra_friendly} ${extra_ending}. That will give you enough to withdraw ${current_level_friendly} ${current_level_ending}, but you'll be overpaying your mining fee by ${overpayment_friendly} ${overpayment_ending}.</p><p>What do you want to do?</p><p><button onclick="specialDeposit( ${deposit_for_next_level}, ${next_level} )">Deposit ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending}</button></p><p><button onclick="broadcastAndShowModal( '${txhex}' );">Withdraw now</button></p>` );
                    }

                    // scen_3 = Enough in reversible for level X + fees (and there is no X + 1) AND there is some money in irreversible (1010 & 1110)
                    //     -- one option: (1) pay for level X + fees (and possibly overpay fees)
                    var scen_3 = ( amt_in_reversible_pledges >= levels[ current_level ] + mining_fee_with_no_extra_input && current_level >= levels.length - 1 && some_money_in_irreversible && !we_are_in_scen_9 && !we_are_in_scen_10 );

                    if ( scen_3 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 2_010_000 total: 2_020_000
                        // console.log( "scenario 3: amt_in_reversible_pledges", 71_000_000_000, "and total", 81_000_000_000 );
                        var utxos_to_block = [];
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            var input = {
                                txid: item[ "txid" ],
                                vout: item[ "vout" ],
                                prevout: {
                                    value: item[ "value" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                                }
                            }
                            if ( `num_${levels[ current_level ]}` in item[ "levels_with_valid_sig" ] ) {
                                var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ current_level ]}` ];
                                input.witness = [ sig ];
                                inputs.push( input );
                            }
                            else {
                                utxos_to_block.push( i );
                                continue;
                            }
                        }
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            if ( utxos_to_block.includes( index ) ) continue;
                            var contribution_txdata = tapscript.Tx.create({
                                vin: inputs,
                                vout: [{
                                    value: levels[ current_level ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                                }],
                            });
                            var tapleaf = item[ "tapleaf" ];
                            var script = item[ "script" ];
                            var cblock = item[ "cblock" ];
                            var their_key = item[ "contributor_key" ];
                            var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                            var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                            var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                            var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                            if ( !isValid ) {
                                contribution_txdata.vin.splice( i, 1 );
                                continue;
                            }
                            contribution_txdata.vin[ index ].witness.unshift( mysig );
                            contribution_txdata.vin[ index ].witness.push( script, cblock );
                            // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                        }
                        var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                        // console.log( txhex );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. ${amt_in_reversible_pledges_friendly} ${amt_in_reversible_pledges_ending} of that is in smart contracts and the remainder (${remainder_friendly} ${remainder_ending}) was sent to you directly. Due to the way semaphore is coded, you can only withdraw up to 10x your goal, so you can only withdraw ${current_level_friendly} ${current_level_ending}, and the remainder (${remainder_if_exeeding_10x_friendly} ${remainder_if_exeeding_10x_ending}) will go to miners as fees.</p><p><button onclick="broadcastAndShowModal( '${txhex}' );">Ok, withdraw now</button></p>` );
                    }

                    // scen_4 = Enough in reversible for level X + fees (and there is no X + 1) AND there is NO money in irreversible (1011 & 1111)
                    //     -- one option: (1) pay for level X + fees (and possibly overpay fees)
                    var scen_4 = ( amt_in_reversible_pledges >= levels[ current_level ] + mining_fee_with_no_extra_input && current_level >= levels.length - 1 && !some_money_in_irreversible && !we_are_in_scen_9 && !we_are_in_scen_10 );

                    if ( scen_4 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 2_010_000 total: 2_010_000
                        // console.log( "scenario 4: amt_in_reversible_pledges", 71_000_000_000, "and total", 71_000_000_000 );
                        var utxos_to_block = [];
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            var input = {
                                txid: item[ "txid" ],
                                vout: item[ "vout" ],
                                prevout: {
                                    value: item[ "value" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                                }
                            }
                            if ( `num_${levels[ current_level ]}` in item[ "levels_with_valid_sig" ] ) {
                                var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ current_level ]}` ];
                                input.witness = [ sig ];
                                inputs.push( input );
                            }
                            else {
                                utxos_to_block.push( i );
                                continue;
                            }
                        }
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            if ( utxos_to_block.includes( index ) ) continue;
                            var contribution_txdata = tapscript.Tx.create({
                                vin: inputs,
                                vout: [{
                                    value: levels[ current_level ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                                }],
                            });
                            var tapleaf = item[ "tapleaf" ];
                            var script = item[ "script" ];
                            var cblock = item[ "cblock" ];
                            var their_key = item[ "contributor_key" ];
                            var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                            var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                            var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                            var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                            if ( !isValid ) {
                                contribution_txdata.vin.splice( i, 1 );
                                continue;
                            }
                            contribution_txdata.vin[ index ].witness.unshift( mysig );
                            contribution_txdata.vin[ index ].witness.push( script, cblock );
                            // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                        }
                        var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                        // console.log( txhex );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. Due to the way semaphore is coded, you can only withdraw up to 10x your goal, so you can only withdraw ${current_level_friendly} ${current_level_ending}, and the remainder (${remainder_if_exeeding_10x_friendly} ${remainder_if_exeeding_10x_ending}) will go to miners as fees.</p><p><button onclick="broadcastAndShowModal( '${txhex}' );">Ok, withdraw now</button></p>` );
                    }

                    // scen_5 = Enough in reversible for level X (where X > 0 and there is an X + 1) BUT not enough to pay for level X plus fees DOUBLE BUT there is some money in irreversible (0110)
                    //     -- three options: (1) contribute enough to pay for level X + fees (and remind user they can take some of this from irreversible) (2) contribute enough to pay for level X + 1 + fees (and remind user they can take some of this from irreversible) (3) step down a level (and possibly overpay fees)
                    var scen_5 = ( amt_in_reversible_pledges >= levels[ current_level ] && amt_in_reversible_pledges < levels[ current_level ] + mining_fee_with_no_extra_input && current_level > 0 && current_level < levels.length - 1 && some_money_in_irreversible && !we_are_in_scen_9 && !we_are_in_scen_10 );

                    if ( scen_5 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 210_020 total: 220_020
                        // console.log( "scenario 5: amt_in_reversible_pledges", 606_000_020, "and total", 700_000_020 );
                        var utxos_to_block = [];
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            var input = {
                                txid: item[ "txid" ],
                                vout: item[ "vout" ],
                                prevout: {
                                    value: item[ "value" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                                }
                            }
                            if ( `num_${levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ]}` in item[ "levels_with_valid_sig" ] ) {
                                var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ]}` ];
                                input.witness = [ sig ];
                                inputs.push( input );
                            }
                            else {
                                utxos_to_block.push( i );
                                continue;
                            }
                        }
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            if ( utxos_to_block.includes( index ) ) continue;
                            var contribution_txdata = tapscript.Tx.create({
                                vin: inputs,
                                vout: [{
                                    value: levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                                }],
                            });
                            var tapleaf = item[ "tapleaf" ];
                            var script = item[ "script" ];
                            var cblock = item[ "cblock" ];
                            var their_key = item[ "contributor_key" ];
                            var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                            var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                            var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                            var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                            if ( !isValid ) {
                                contribution_txdata.vin.splice( i, 1 );
                                continue;
                            }
                            contribution_txdata.vin[ index ].witness.unshift( mysig );
                            contribution_txdata.vin[ index ].witness.push( script, cblock );
                            // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                        }
                        var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                        // console.log( txhex );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. ${amt_in_reversible_pledges_friendly} ${amt_in_reversible_pledges_ending} of that is in smart contracts and the remainder (${remainder_friendly} ${remainder_ending}) was sent to you directly. Given that you can only withdraw in increments of 1% above your goal AND you don't have enough to pay mining fees for your current increment, you have three options to withdraw your funds (btw all of the following options account for mining fees): (1) you can withdraw ${current_level_friendly} ${current_level_ending} by contributing ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending} to your own fundraiser to pay for mining fees, (2) you can withdraw ${next_level_friendly} ${next_level_ending} by contributing ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending} to your own fundraiser, or, if neither of those seem like good options to you, you can withdraw what you have right now and use part of it to pay the mining fee. But if you withdraw now, the fee will be ${more_extra_friendly} ${more_extra_ending} -- enough to withdraw ${amount_i_can_withdraw_if_i_must_step_down_friendly} ${amount_i_can_withdraw_if_i_must_step_down_ending}, but it's a fee *overpayment* of ${more_overpayment_friendly} ${more_overpayment_ending}.</p><p>What do you want to do?</p><p><button onclick="specialDeposit( ${deposit_for_current_level}, ${current_level} )">Deposit ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending}</button></p><p><button onclick="specialDeposit( ${deposit_for_next_level}, ${next_level} )">Deposit ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending}</button></p><p><button onclick="broadcastAndShowModal( '${txhex}' );">Withdraw now</button></p>` );
                    }

                    // scen_6 = Enough in reversible for level X (where X > 0 and there is an X + 1) BUT not enough to pay for level X plus fees AND there is no money in irreversible (0111)
                    //     -- three options: (1) contribute enough to pay for level X + fees (and DO NOT say they can take some of this from irreversible) (2) contribute enough to pay for level X + 1 + fees (and DO NOT say they can take some of this from irreversible) (3) step down a level (and possibly overpay fees)
                    var scen_6 = ( amt_in_reversible_pledges >= levels[ current_level ] && amt_in_reversible_pledges < levels[ current_level ] + mining_fee_with_no_extra_input && current_level > 0 && current_level < levels.length - 1 && !some_money_in_irreversible && !we_are_in_scen_9 && !we_are_in_scen_10 );

                    if ( scen_6 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 210_020 total: 210_020
                        // console.log( "scenario 6: amt_in_reversible_pledges", 606_000_020, "and total", 606_000_020 );
                        var utxos_to_block = [];
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            var input = {
                                txid: item[ "txid" ],
                                vout: item[ "vout" ],
                                prevout: {
                                    value: item[ "value" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                                }
                            }
                            if ( `num_${levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ]}` in item[ "levels_with_valid_sig" ] ) {
                                var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ]}` ];
                                input.witness = [ sig ];
                                inputs.push( input );
                            }
                            else {
                                utxos_to_block.push( i );
                                continue;
                            }
                        }
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            if ( utxos_to_block.includes( index ) ) continue;
                            var contribution_txdata = tapscript.Tx.create({
                                vin: inputs,
                                vout: [{
                                    value: levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                                }],
                            });
                            var tapleaf = item[ "tapleaf" ];
                            var script = item[ "script" ];
                            var cblock = item[ "cblock" ];
                            var their_key = item[ "contributor_key" ];
                            var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                            var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                            var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                            var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                            if ( !isValid ) {
                                contribution_txdata.vin.splice( i, 1 );
                                continue;
                            }
                            contribution_txdata.vin[ index ].witness.unshift( mysig );
                            contribution_txdata.vin[ index ].witness.push( script, cblock );
                            // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                        }
                        var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                        // console.log( txhex );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. Given that you can only withdraw in increments of 1% above your goal AND you don't have enough to pay mining fees for your current increment, you have three options to withdraw your funds (btw all of the following options account for mining fees): (1) you can withdraw ${current_level_friendly} ${current_level_ending} by contributing ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending} to your own fundraiser to pay for mining fees, (2) you can withdraw ${next_level_friendly} ${next_level_ending} by contributing ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending} to your own fundraiser, or, if neither of those seem like good options to you, you can withdraw what you have right now and use part of it to pay the mining fee. But if you withdraw now, the fee will be ${more_extra_friendly} ${more_extra_ending} -- enough to withdraw ${amount_i_can_withdraw_if_i_must_step_down_friendly} ${amount_i_can_withdraw_if_i_must_step_down_ending}, but it's a fee *overpayment* of ${more_overpayment_friendly} ${more_overpayment_ending}.</p><p>What do you want to do?</p><p><button onclick="specialDeposit( ${deposit_for_current_level}, ${current_level}, ${levels} )">Deposit ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending}</button></p><p><button onclick="specialDeposit( ${deposit_for_next_level}, ${next_level} )">Deposit ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending}</button></p><p><button onclick="broadcastAndShowModal( '${txhex}' );">Withdraw now</button></p>` );
                    }

                    // scen_7 = Enough in reversible for level X (where X > 0 and there is NO X + 1) BUT not enough to pay for level X plus fees DOUBLE BUT there is some money in irreversible (0100)
                    //     -- two options: (1) contribute enough to pay for level X + fees (and remind user they can take some of this from irreversible) (2) step down a level (and possibly overpay fees)
                    var scen_7 = ( amt_in_reversible_pledges >= levels[ current_level ] && amt_in_reversible_pledges < levels[ current_level ] + mining_fee_with_no_extra_input && current_level > 0 && current_level == levels.length - 1 && some_money_in_irreversible && !we_are_in_scen_9 && !we_are_in_scen_10 );

                    if ( scen_7 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 2_000_020 total: 2_010_020
                        // console.log( "scenario 7: amt_in_reversible_pledges", 6_000_000_020, "and total", 6_000_000_120 );
                        var utxos_to_block = [];
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            var input = {
                                txid: item[ "txid" ],
                                vout: item[ "vout" ],
                                prevout: {
                                    value: item[ "value" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                                }
                            }
                            if ( `num_${levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ]}` in item[ "levels_with_valid_sig" ] ) {
                                var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ]}` ];
                                input.witness = [ sig ];
                                inputs.push( input );
                            }
                            else {
                                utxos_to_block.push( i );
                                continue;
                            }
                        }
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            if ( utxos_to_block.includes( index ) ) continue;
                            var contribution_txdata = tapscript.Tx.create({
                                vin: inputs,
                                vout: [{
                                    value: levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                                }],
                            });
                            var tapleaf = item[ "tapleaf" ];
                            var script = item[ "script" ];
                            var cblock = item[ "cblock" ];
                            var their_key = item[ "contributor_key" ];
                            var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                            var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                            var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                            var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                            if ( !isValid ) {
                                contribution_txdata.vin.splice( i, 1 );
                                continue;
                            }
                            contribution_txdata.vin[ index ].witness.unshift( mysig );
                            contribution_txdata.vin[ index ].witness.push( script, cblock );
                            // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                        }
                        var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                        // console.log( txhex );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. ${amt_in_reversible_pledges_friendly} ${amt_in_reversible_pledges_ending} of that is in smart contracts and the remainder (${remainder_friendly} ${remainder_ending}) was sent to you directly. Given that you can only withdraw in increments of 1% above your goal, you have two options to withdraw your funds (btw both of the following options account for mining fees): you can withdraw ${current_level_friendly} ${current_level_ending} by contributing ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending} to your own fundraiser to pay for mining fees, or, if that doesn't seem like a good option to you, you can pay a fee of ${more_extra_friendly} ${more_extra_ending}. That will give you enough to withdraw ${amount_i_can_withdraw_if_i_must_step_down_friendly} ${amount_i_can_withdraw_if_i_must_step_down_ending}, but you'll be overpaying your mining fee by ${more_overpayment_friendly} ${more_overpayment_ending}.</p><p>What do you want to do?</p><p><button onclick="specialDeposit( ${deposit_for_current_level}, ${current_level} )">Deposit ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending}</button></p><p><button onclick="broadcastAndShowModal( '${txhex}' );">Withdraw now</button></p>` );
                    }

                    // scen_8 = Enough in reversible for level X (where X > 0 and there is NO X + 1) but not enough to pay for level X plus fees AND there is no money in irreversible (0101)
                    //     -- two options: (1) contribute enough to pay for level X + fees (and DO NOT say they can take some of this from irreversible) (2) step down a level (and possibly overpay fees)
                    var scen_8 = ( amt_in_reversible_pledges >= levels[ current_level ] && amt_in_reversible_pledges < levels[ current_level ] + mining_fee_with_no_extra_input && current_level > 0 && current_level == levels.length - 1 && !some_money_in_irreversible && !we_are_in_scen_9 && !we_are_in_scen_10 );

                    if ( scen_8 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 2_000_020 total: 2_000_020
                        // console.log( "scenario 8: amt_in_reversible_pledges", 6_000_000_020, "and total", 6_000_000_020 );
                        var utxos_to_block = [];
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            var input = {
                                txid: item[ "txid" ],
                                vout: item[ "vout" ],
                                prevout: {
                                    value: item[ "value" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                                }
                            }
                            if ( `num_${levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ]}` in item[ "levels_with_valid_sig" ] ) {
                                var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ]}` ];
                                input.witness = [ sig ];
                                inputs.push( input );
                            }
                            else {
                                utxos_to_block.push( i );
                                continue;
                            }
                        }
                        var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                            var item = contributed_utxos[ i ];
                            var index = i;
                            if ( utxos_to_block.includes( index ) ) continue;
                            var contribution_txdata = tapscript.Tx.create({
                                vin: inputs,
                                vout: [{
                                    value: levels[ index_of_amount_i_can_withdraw_if_i_must_step_down ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                                }],
                            });
                            var tapleaf = item[ "tapleaf" ];
                            var script = item[ "script" ];
                            var cblock = item[ "cblock" ];
                            var their_key = item[ "contributor_key" ];
                            var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                            var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                            var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                            var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                            if ( !isValid ) {
                                contribution_txdata.vin.splice( i, 1 );
                                continue;
                            }
                            contribution_txdata.vin[ index ].witness.unshift( mysig );
                            contribution_txdata.vin[ index ].witness.push( script, cblock );
                            // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                        }
                        var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                        // console.log( txhex );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. Given that you can only withdraw in increments of 1% above your goal, you have two options to withdraw your funds (btw both of the following options account for mining fees): you can withdraw ${current_level_friendly} ${current_level_ending} by contributing ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending} to your own fundraiser to pay for mining fees, or, if that doesn't seem like a good option to you, you can pay a fee of ${more_extra_friendly} ${more_extra_ending}. That will give you enough to withdraw ${amount_i_can_withdraw_if_i_must_step_down_friendly} ${amount_i_can_withdraw_if_i_must_step_down_ending}, but you'll be overpaying your mining fee by ${more_overpayment_friendly} ${more_overpayment_ending}.</p><p>What do you want to do?</p><p><button onclick="specialDeposit( ${deposit_for_current_level}, ${current_level} )">Deposit ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending}</button></p><p><button onclick="broadcastAndShowModal( '${txhex}' );">Withdraw now</button></p>` );
                    }

                    // scen_9 = Enough in reversible for level X (where X == 0) but not enough to pay for level X plus fees DOUBLE BUT there is some money in irreversible (0000 & 0010) <-- the first of those is impossible so it is really just 0010
                    //     -- two options: (1) contribute enough to pay for level X + fees (and remind user they can take some of this from irreversible) (2) contribute enough to pay for level X + 1 + fees (and remind user they can take some of this from irreversible)
                    var scen_9 = ( we_are_in_scen_9 || ( amt_in_reversible_pledges >= levels[ current_level ] && amt_in_reversible_pledges < levels[ current_level ] + mining_fee_with_no_extra_input && current_level == 0 && some_money_in_irreversible ) );

                    if ( scen_9 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 200_020 total: 200_820
                        // console.log( "scenario 9: amt_in_reversible_pledges", 600_000_020, "and total", 600_000_120 );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. ${amt_in_reversible_pledges_friendly} ${amt_in_reversible_pledges_ending} of that is in smart contracts and the remainder (${remainder_friendly} ${remainder_ending}) was sent to you directly. Given that you can only withdraw in increments of 1% above your goal AND you don't have enough to pay mining fees for your current increment, you have two options to withdraw your funds (btw both of the following options account for mining fees): you can withdraw ${current_level_friendly} ${current_level_ending} by contributing ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending} to your own fundraiser to pay for mining fees, or you can withdraw ${next_level_friendly} ${next_level_ending} by contributing ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending} to your own fundraiser.</p><p>What do you want to do?</p><p><button onclick="specialDeposit( ${deposit_for_current_level}, ${current_level}, ${levels} )">Deposit ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending}</button></p><p><button onclick="specialDeposit( ${deposit_for_next_level}, ${next_level} )">Deposit ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending}</button></p>` );
                    }

                    // scen_10 = Enough in reversible for level X (where X == 0) but not enough to pay for level X plus fees AND there is no money in irreversible (0001 & 0011) <-- the first of those is impossible so it is really just 0011
                    //     -- two options: (1) contribute enough to pay for level X + 1 + fees (and DO NOT say they can take some of this from irreversible) (2) contribute enough to pay for level X + fees (and DO NOT say they can take some of this from irreversible)
                    var scen_10 = ( we_are_in_scen_10 || ( amt_in_reversible_pledges >= levels[ current_level ] && amt_in_reversible_pledges < levels[ current_level ] + mining_fee_with_no_extra_input && current_level == 0 && !some_money_in_irreversible ) );

                    if ( scen_10 ) {
                        //goal: 200_000 aka 0.002 btc reversible: 200_020 total: 200_020
                        // console.log( "scenario 10: amt_in_reversible_pledges", 600_000_020, "and total", 600_000_020 );
                        return showModal( `<p>You received ${total_friendly} ${total_ending} total. Given that you can only withdraw in increments of 1% above your goal AND you don't have enough to pay mining fees for your current increment, you have two options to withdraw your funds (btw both of the following options account for mining fees): you can withdraw ${current_level_friendly} ${current_level_ending} by contributing ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending} to your own fundraiser to pay for mining fees, or you can withdraw ${next_level_friendly} ${next_level_ending} by contributing ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending} to your own fundraiser.</p><p>What do you want to do?</p><p><button onclick="specialDeposit( ${deposit_for_current_level}, ${current_level} )">Deposit ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending}</button></p><p><button onclick="specialDeposit( ${deposit_for_next_level}, ${next_level} )">Deposit ${deposit_for_next_level_friendly} ${deposit_for_next_level_ending}</button></p>` );
                    }

                    //the final unaccounted-for situation (I think) is where the fundraiser has enough money in total to withdraw but
                    //not enough of that is in reversible pledges to do anything -- account for this
                    return showModal( `<p>You received ${total_friendly} ${total_ending} total. ${amt_in_reversible_pledges_friendly} ${amt_in_reversible_pledges_ending} of that is in smart contracts and the remainder (${remainder_friendly} ${remainder_ending}) was sent to you directly. Therefore, you can withdraw ${current_level_friendly} ${current_level_ending} only by contributing ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending} to your own fundraiser to get the amount in smart contracts "up to" your goal and pay for mining fees.</p><p>Click the button below to do that.</p><p><button onclick="specialDeposit( ${deposit_for_current_level}, ${current_level} )">Deposit ${deposit_for_current_level_friendly} ${deposit_for_current_level_ending}</button></p>` );
                }
                checkForUtxos();
            }
            function modalVanish() {
                $( ".black-bg" ).classList.add( "hidden" );
                $( ".modal" ).classList.add( "hidden" );
            }
            function showModal( content, block_til_clear ) {
                if ( block_til_clear ) var fn = `modalVanish();sessionStorage[ 'modal_cleared' ] = true;`; else var fn = `modalVanish();`;
                $( ".modal" ).innerHTML = `<div class="x_modal" style="position: absolute;right: 1rem;top: 0.5rem;font-size: 2rem; cursor: pointer; color: black;" onclick="${fn}">&times;</div>`;
                $( ".modal" ).innerHTML += `<div style="overflow-y: auto; max-height: 80vh; margin-top: 1.5rem;">${content}</div>`;
                $( ".black-bg" ).classList.remove( "hidden" );
                $( ".modal" ).classList.remove( "hidden" );
            }
            var login = () => {
                showModal( `
                    <form>
                        <p style="font-weight: bold;">To log in, upload the backup file you got when you created or contributed to this project</p>
                        <p><input type="file" onchange="{import_data( this.files[ 0 ] );}" /></p>
                    </form>
                ` );
            }
            var logout = () => {
                $( '.login_btn' ).innerText = "Log in";
                $( '.login_btn' ).onclick = login;
                window.location.reload();
            }
            var import_data = file => {
                var fileReader = new FileReader();
                fileReader.onloadend = async () => {
                    var b64 = fileReader.result.toString().substring( fileReader.result.toString().indexOf( "base64," ) + 7 );
                    var text = nostr_image_host.hexToText( base64ToHex( b64 ) );
                    if ( !isValidJson( text ) ) return;
                    var backed_up_data = JSON.parse( text );
                    if ( !( "fundraiser_id" in backed_up_data ) ) return alert( `Sorry, that is an invalid file! Try again or ask a developer for assistance` );
                    if ( $_GET[ "fundraiser" ] && $_GET[ "fundraiser" ] != backed_up_data[ "fundraiser_id" ] ) return showModal( `Sorry, wrong fundraiser! Try again` );
                    if ( !$_GET[ "fundraiser" ] ) $_GET[ "fundraiser" ] = backed_up_data[ "fundraiser_id" ];
                    btc_sec = backed_up_data[ "privkey" ];
                    btc_pub = nobleSecp256k1.getPublicKey( btc_sec, true ).substring( 2 );
                    if ( socket ) socket.close();
                    showModal( `reloading page...` );
                    await loadFundraiser();
                    await nostr_image_host.waitSomeSeconds( 1 );
                    setTimeout( () => {if ( $( '.modal' ).innerHTML.includes( "reloading page..." ) && !$( '.modal' ).classList.contains( "hidden" ) ) $( '.x_modal' ).click();}, 2000 );
                    $( '.login_btn' ).innerText = "Log out";
                    $( '.login_btn' ).onclick = logout;
                    if ( $( '.modal' ).innerHTML.includes( "reloading page..." ) && !$( '.modal' ).classList.contains( "hidden" ) ) $( '.x_modal' ).click();
                }
                fileReader.readAsDataURL( file );
            }
            function base64ToHex(str) {
                var raw = atob(str);
                var result = '';
                var i; for ( i=0; i<raw.length; i++ ) {
                    var hex = raw.charCodeAt( i ).toString( 16 );
                    result += hex.length % 2 ? '0' + hex : hex;
                }
                return result.toLowerCase();
            }
            function isValidJson( content ) {
                if ( !content ) return;
                try {  
                    var json = JSON.parse( content );
                } catch ( e ) {
                    return;
                }
                return true;
            }
            sessionStorage.removeItem( "modal_cleared" );
            sessionStorage.removeItem( "reversible" );
            sessionStorage.removeItem( "recovery" );
            sessionStorage.removeItem( "ln_amount" );
            sessionStorage.removeItem( "ln_public" );
            async function getNote( item ) {
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( sessionStorage[ item ] );
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( sessionStorage[ item ] );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }
            function convertHMS( value ) {
                if ( value < 0 ) value = 0;
                var sec = parseInt(value, 10); // convert value to number if it's string
                var years = Math.floor(sec / 31536000); // get years
                var months = Math.floor((sec - (years * 31536000)) / 2592000); // get months
                var days = Math.floor((sec - (years * 31536000) - (months * 2592000)) / 86400); // get days
                var hours = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400)) / 3600); // get hours
                var minutes = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600)) / 60); // get minutes
                var seconds = sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600) - (minutes * 60); //  get seconds
                var yearsstring = (years != 1) ? `years`:`year`;
                var monthsstring = (months != 1) ?  `months`:`month`;
                var daysstring = (days != 1) ? `days`:`day`;
                var hoursstring = (hours != 1) ? `hours`:`hour`;
                var minutesstring = (minutes != 1) ? `minutes`:`minute`;
                var secondsstring = (seconds != 1) ? `seconds`:`second`;
                if ( years > 0 ) return `${years} ${yearsstring} ${months} ${monthsstring} ${days} ${daysstring} ${hours} ${hoursstring} ${minutes} ${minutesstring} ${seconds} ${secondsstring}`;
                if ( months > 0 ) return `${months} ${monthsstring} ${days} ${daysstring} ${hours} ${hoursstring} ${minutes} ${minutesstring} ${seconds} ${secondsstring}`;
                if ( days > 0 ) return `${days} ${daysstring} ${hours} ${hoursstring} ${minutes} ${minutesstring} ${seconds} ${secondsstring}`;
                if ( hours > 0 ) return `${hours} ${hoursstring} ${minutes} ${minutesstring} ${seconds} ${secondsstring}`;
                if ( minutes > 0 ) return `${minutes} ${minutesstring} ${seconds} ${secondsstring}`;
                if ( seconds == 0 ) return `${seconds} seconds`;
                return `${seconds} ${secondsstring}`;
            }
            async function getBlockheight( network ) {
                var data = await getData( `https://${btc_net}/${network}api/blocks/tip/height` );
                return Number( data );
            }
            var timeloop = async seconds => {
                var time_left = convertHMS( seconds );
                if ( $( '.countdown_div' ) && $( '.image_and_name' ) && $( '.image_and_name' ).style.backgroundImage ) {
                    $( '.login_btn' ).classList.remove( "hidden" );
                    $( '.project_header' ).classList.remove( "hidden" );
                    $( '.project_body' ).classList.remove( "hidden" );
                    $( '.countdown_div' ).innerHTML = `<span class="countdown_label">Fundraiser ends in </span><span class="countdown">loading...</span>`;
                    $( '.countdown' ).innerText = time_left;
                }
                await nostr_image_host.waitSomeSeconds( 1 );
                timeloop_seconds = seconds - 1;
                timeloop( timeloop_seconds );
            }
            var show_pledge_options = () => {
                showModal( `
                    <div>
                        <p>What kind of pledge do you want to make?</p>
                        <p><button class="reversibility_button irreversible">Irreversible</button></p>
                        <p><button class="reversibility_button reversible">Reversible</button></p>
                        <p><span class="what_are_these" style="color: blue; text-decoration: underline; cursor: pointer;">What are these?</span></p>
                    </div>
                `, true );
                $( '.what_are_these' ).onclick = () => {what_are_these();}
                $( '.irreversible' ).onclick = () => {showIrreversible();}
                $( '.reversible' ).onclick = () => {
                    sessionStorage[ "reversible" ] = true;
                    sessionStorage[ "modal_cleared" ] = true;
                }
            }
            var what_are_these = () => {
                showModal( `
                    <div>
                        <p><button class="back_btn_1">Back</button></p>
                        <p>An irreversible pledge sends your money directly to the person or group who made the fundraiser. They get to keep that money even if the fundraiser does not reach its goal.</p><p>A reversible pledge sends your money to a bitcoin smart contract where you may recover it at any time, and the person or group who made the fundraiser can only take it if they reach their goal. Otherwise, this website will attempt to do an automatic refund.</p><p>Automatic refunds are not guaranteed to work, so you will also receive a backup file you can use to unilaterally recover your funds in case the site goes down.</p>
                        <p><button class="back_btn_2">Back</button></p>
                    </div>
                `, true );
                $( '.back_btn_1' ).onclick = () => {show_pledge_options();}
                $( '.back_btn_2' ).onclick = () => {show_pledge_options();}
            }
            function createQR( content ) {
                var dataUriPngImage = document.createElement( "img" ),
                s = QRCode.generatePNG( content, {
                    ecclevel: "M",
                    format: "html",
                    fillcolor: "#FFFFFF",
                    textcolor: "#000000",
                    margin: 4,
                    modulesize: 8,
                });
                dataUriPngImage.src = s;
                dataUriPngImage.className = "qr_code";
                dataUriPngImage.style.width = "100%";
                return dataUriPngImage;
            }
            var utxoloop = async ( address, original_utxos ) => {
                var new_utxo;
                var current_utxos = await getData( `https://${btc_net}/api/address/${address}/utxo` );
                current_utxos = JSON.parse( current_utxos );
                if ( current_utxos.length <= original_utxos.length ) {
                    await nostr_image_host.waitSomeSeconds( 3 );
                    var new_utxo = await utxoloop( address, original_utxos );
                    return new_utxo;
                }
                var simplified_utxos = [];
                current_utxos.forEach( item => simplified_utxos.push( `${item[ "txid" ]}:${item[ "vout" ]}:${item[ "value" ]}` ) );
                simplified_utxos.every( item => {
                    var simplified_item = [ item.split( ":" )[ 0 ], item.split( ":" )[ 1 ] ].join( ":" );
                    if ( !current_utxos.includes( simplified_item ) ) return new_utxo = item;
                    return true;
                });
                return new_utxo;
            }
            function saveData( data, fileName ) {
                var a = document.createElement("a");
                document.body.appendChild(a);
                a.style = "display: none";
                var json = JSON.stringify(data);
                var blob = new Blob([json], {type: "octet/stream"});
                var url = window.URL.createObjectURL(blob);
                a.href = url;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);
            }
            var processContrib = async e => {
                var [ type, subId, event ] = JSON.parse( e.data );
                var { kind, content, tags } = event || {}
                if ( !event || event === true ) return;
                var json = JSON.parse( content );
                var fundraiser = project.project_key;
                if ( !( "fundraiser_id" in json ) ) return;
                if ( json[ "fundraiser_id" ] != $_GET[ "fundraiser" ] ) return;
                if ( !( "is_lightning" in json ) || !json[ "is_lightning" ] ) {
                    var utxo_was_spent_in_this_txid_and_vin = false;
                    if ( "contributor_key" in json ) {
                        var script = [ 0, json[ "contributor_key" ], 'OP_CHECKSIGADD', fundraiser, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ];
                        var tapleaf = tapscript.Tap.encodeScript( script );
                        var [ tpubkey, cblock ] = tapscript.Tap.getPubKey( json[ "contributor_key" ], { target: tapleaf });
                        var address = tapscript.Address.p2tr.fromPubKey( tpubkey, mainnet_or_testnet );
                        //stop here and do not update the page if the contributor did not contribute anything
                        // var utxos = await getData( `https://${btc_net}/api/address/${address}/utxo` );
                        // utxos = JSON.parse( utxos );
                        // var amt_pledged_by_this_utxo = 0;
                        // utxos.forEach( item => {
                        //     if ( item[ "txid" ] == json[ "txid" ] && item[ "vout" ] == json[ "vout" ] ) amt_pledged_by_this_utxo = item[ "value" ];
                        // });
                        // if ( !amt_pledged_by_this_utxo ) return;
                        //stop here and do not update the page if the contributor did not contribute anything
                        var txinfo = await getData( `https://${btc_net}/api/address/${address}/txs` );
                        txinfo = JSON.parse( txinfo );
                        var amt_pledged_by_this_utxo = 0;
                        txinfo.every( item => {
                            if (
                                item[ "txid" ] == json[ "txid" ] &&
                                item[ "vout" ][ json[ "vout" ] ] && 
                                item[ "vout" ][ json[ "vout" ] ][ "scriptpubkey_address" ] == address
                            ) {
                                amt_pledged_by_this_utxo = item[ "vout" ][ json[ "vout" ] ][ "value" ];
                                return;
                            }
                            return true;
                        });
                        if ( !amt_pledged_by_this_utxo ) return;
                        //stop here and do not update the page if utxo was revoked
                        var utxo_was_revoked = false;
                        txinfo.every( item => {
                            var item_found;
                            item.vin.every( ( input, index ) => {
                                if (
                                    input[ "txid" ] == json[ "txid" ] &&
                                    input[ "vout" ] == json[ "vout" ]
                                ) {
                                    utxo_was_spent_in_this_txid_and_vin = `${item[ "txid" ]}:${index}`;
                                    item_found = true;
                                    if ( input[ "witness" ].length == 1 ) utxo_was_revoked = true;
                                    else funds_spent_cooperatively = true;
                                    return;
                                }
                                return true;
                            });
                            //the "every" function needs you to return "true" if you haven't found the thing you are looking for
                            //and "false" if you have. By inverting item_found, I make it return true by default, but if the
                            //utxo is found to have been spent, it will flip to false, thus exiting the loop
                            return !item_found;
                        });
                        if ( utxo_was_revoked ) return;
                        //stop here and do not update the page if the sig is invalid
                        var contribution_txdata = tapscript.Tx.create({
                            vin: [{
                                txid: json[ "txid" ],
                                vout: json[ "vout" ],
                                prevout: {
                                    value: amt_pledged_by_this_utxo,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( address ),
                                },
                            }],
                            vout: [{
                                value: project.project_gol,
                                scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                            }],
                        });
                        contribution_txdata.vin[ 0 ].witness = [ json[ "main_sigs" ][ 1 ] ];
                        var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, 0, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                        var isValid = await nobleSecp256k1.schnorr.verify( json[ "main_sigs" ][ 1 ].substring( 0, 128 ), sighash, json[ "contributor_key" ] );
                        if ( !isValid ) return;
                    } else {
                        var address = project.project_add;
                        var txinfo = await getData( `https://${btc_net}/api/tx/${json[ "txid" ]}` );
                        txinfo = JSON.parse( txinfo );
                        var amt_pledged_by_this_utxo = 0;
                        txinfo[ "vout" ].forEach( ( item, index ) => {
                            if ( index == json[ "vout" ] && item[ "scriptpubkey_address" ] == address ) amt_pledged_by_this_utxo = item[ "value" ];
                        });
                        if ( !amt_pledged_by_this_utxo ) return;
                    }
                    if ( used_txid_and_vouts.includes( `${json[ "txid" ]}:${json[ "vout" ]}` ) ) return;
                    used_txid_and_vouts.push( `${json[ "txid" ]}:${json[ "vout" ]}` );
                    //autorefund
                    if ( !!json[ "recovery" ] && !!json[ "recovery_fee" ] && lastblock >= project.project_end + 144 ) {
                        var recovery_txdata = tapscript.Tx.create({
                            vin: [{
                                txid: json[ "txid" ],
                                vout: json[ "vout" ],
                                sequence: 0xfffffffd,
                                prevout: {
                                    value: amt_pledged_by_this_utxo,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( address ),
                                },
                                witness: [ json[ "main_sigs" ][ 0 ] ],
                            }],
                            vout: [{
                                value: amt_pledged_by_this_utxo - json[ "recovery_fee" ],
                                scriptPubKey: tapscript.Address.toScriptPubKey( json[ "recovery" ] ),
                            }],
                            locktime: project.project_end + 144,
                        });
                        var txhex = tapscript.Tx.encode( recovery_txdata ).hex;
                        setTimeout( async () => {
                            await pushBTCpmt( txhex, "" );
                            // var txid = await pushBTCpmt( txhex, "" );
                            // console.log( "autorefund attempted!", txid, txhex );
                        }, Math.floor( Math.random() * 1000 ) );
                    } else {
                        // if ( !!json[ "recovery" ] && !!json[ "recovery_fee" ] ) console.log( `no autorefund right now because it is only block ${lastblock} and it needs to be block ${project.project_end + 144} -- which is in ${project.project_end + 144 - lastblock} blocks` );
                    }
                    if ( "contributor_key" in json && !utxo_was_spent_in_this_txid_and_vin ) contributed_utxos.push( { txid: json[ "txid" ], vout: json[ "vout" ], value: amt_pledged_by_this_utxo, address, main_sigs: json[ "main_sigs" ], extra_sigs_id: json[ "extra_sigs_id" ], tapleaf, script, cblock, contributor_key: json[ "contributor_key" ], levels_with_valid_sig: {} } );
                    if ( json[ "contributor_key" ] == btc_pub ) checkForUtxos();
                } else {
                    if ( !( "project_lna" in project ) || !project.project_lna ) return;
                    if ( !( "invoice" in json ) ) return;
                    if ( !( "preimage" in json ) ) return;
                    var is_valid_invoice = isValidInvoice( json[ "invoice" ] );
                    if ( !is_valid_invoice ) return;
                    var invoice = json[ "invoice" ];
                    var ln_preimage = json[ "preimage" ];
                    if ( !ln_preimage ) return;
                    var lnaddress = project.project_lna;
                    var split_lna = lnaddress.split( "@" );
                    var domain = split_lna[ 1 ];
                    var username = split_lna[ 0 ];
                    if ( !project.has_verify ) {
                        if ( !isValidHex( ln_preimage ) ) return;
                        //get payment hash from invoice and check if preimage matches it
                        var expected_pmthash = getInvoicePmthash( invoice );
                        var real_pmthash = SHA256( nostr_image_host.hexToBytes( ln_preimage ) );
                        var they_match = expected_pmthash == real_pmthash;
                        if ( !they_match ) return;
                    } else {
                        try {
                            var url = new URL( ln_preimage );
                            if ( url.hostname != domain ) return;
                            var settlement_info = await getData( ln_preimage );
                            settlement_info = JSON.parse( settlement_info );
                            if ( settlement_info[ "pr" ] != invoice ) return;
                            var settled = settlement_info[ "settled" ];
                        } catch( e ) {
                            var settled = false;
                        }
                        if ( !settled ) return;
                    }
                    //then get expected description hash and check if actual one matches it
                    var url = `https://${domain}/.well-known/lnurlp/${username}`;
                    var ln_info = await getData( url );
                    ln_info = JSON.parse( ln_info );
                    var minSendable = ln_info[ "minSendable" ];
                    var callback = ln_info[ "callback" ];
                    var second_url = `${callback}?amount=${minSendable}`;
                    var invoice_info = await getData( second_url );
                    invoice_info = JSON.parse( invoice_info );
                    var test_invoice = invoice_info[ "pr" ];
                    var expected_deschash = getInvoiceDeschash( test_invoice );
                    var real_deschash = getInvoiceDeschash( invoice );
                    if ( expected_deschash != real_deschash ) return;
                    //then get public key from invoice and check if it matches the public
                    //key you get from an invoice for the *real* recipient's lightning
                    //address
                    var expected_pubkey = getInvoicePubkey( test_invoice );
                    var real_pubkey = getInvoicePubkey( invoice );
                    if ( expected_pubkey != real_pubkey ) return;
                    //then check the invoice's signature and ensure it validates for the pubkey
                    //ok I don't think I actually have to do this part because looking through
                    //the bolt11 library I found that it throws an error when validating an
                    //invoice if the signature is not valid: "Signature, message, and
                    //recoveryID did not produce the same pubkey as payeeNodeKey"
                    //-- that implies that it tries to "recover" the pubkey using the signature
                    //and the message, and if the recovered pubkey doesn't match the one that
                    //supposedly created this invoice, it throws an error. Also, the error
                    //right after that, "Reconstruction with signature and recoveryID requires
                    //payeeNodeKey to verify correctness of input data," implies that if there
                    //IS no "payeeNodeKey" to validate against it will ALSO through an error
                    //so since I already checked if the invoice is valid I already know the
                    //signature validates for the given pubkey, and so if that matches the
                    //one I expect then I know the invoice is good -- yay!
                    var amt_pledged_by_this_utxo = getInvoiceAmount( json[ "invoice" ] );
                }
                var num_of_pledgers = Number( $( '.num_of_pledgers' ).innerText ) + 1;
                $( '.num_of_pledgers' ).innerText = num_of_pledgers;
                var total_before_now = $( '.raised' ).innerText.replaceAll( ",", "" );
                if ( total_before_now.includes( "." ) ) {
                    var num_of_digits_after_period = total_before_now.substring( total_before_now.indexOf( "." ) + 1 ).length;
                    var string_of_zeros = "";
                    var i; for ( i=0; i<8 - num_of_digits_after_period; i++ ) string_of_zeros = string_of_zeros + "0";
                    total_before_now = total_before_now.replaceAll( ".", "" );
                    total_before_now = total_before_now + string_of_zeros;
                }
                var total_amt_pledged = Number( total_before_now ) + amt_pledged_by_this_utxo;
                var original_total_amt_pledged = total_amt_pledged;
                var raised_ending = "SATS";
                if ( total_amt_pledged > 1000000 ) {
                    total_amt_pledged = satsToBitcoin( total_amt_pledged );
                    raised_ending = "BTC";
                } else {
                    total_amt_pledged = total_amt_pledged.toLocaleString();
                }
                $( '.raised' ).innerText = total_amt_pledged;
                $( '.raised_ending' ).innerText = raised_ending;
                var percent_funded = Number( ( ( original_total_amt_pledged / project.project_gol ) * 100 ).toFixed( 2 ) );
                $( '.percent_funded' ).innerText = percent_funded + "%";
                var div1 = document.createElement( "div" );
                var div2 = document.createElement( "div" );
                var html = `<div class="comment">`;
                html += `<div class="contrib_div"><span class="contrib"></span></div>`;
                if ( json[ "public_comment" ] ) html += `<div class="inner_comment_div"><span class="inner_comment"></span></div>`;
                html += `</div>`;
                div1.innerHTML = html;
                div2.innerHTML = html;
                div1 = div1.firstElementChild;
                div2 = div2.firstElementChild;
                var contrib = amt_pledged_by_this_utxo;
                var contrib_ending = " sats";
                if ( contrib > 1000000 ) {
                    contrib = satsToBitcoin( contrib );
                    contrib_ending = " btc";
                } else {
                    contrib = contrib.toLocaleString();
                }
                div1.getElementsByClassName( "contrib" )[ 0 ].innerText = contrib + contrib_ending;
                div2.getElementsByClassName( "contrib" )[ 0 ].innerText = contrib + contrib_ending;
                if ( json[ "public_comment" ] ) div1.getElementsByClassName( "inner_comment" )[ 0 ].innerText = json[ "public_comment" ].substring( 0, 140 );
                if ( json[ "public_comment" ] ) div2.getElementsByClassName( "inner_comment" )[ 0 ].innerText = json[ "public_comment" ].substring( 0, 140 );
                if ( json[ "public_comment" ] ) $( '.column_right' ).append( div1 );
                if ( json[ "public_comment" ] ) $( '.comments_bottom' ).append( div2 );
                if ( json[ "public_comment" ] ) $$( '.comments_label' ).forEach( item => item.classList.remove( "hidden" ) );
            }
            var getContribs = async () => {
                var fundraiser = project.project_key;
                var subId   = nostr_image_host.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 16 );
                var filter  = { "#p": [ fundraiser ], kinds: [ 62116 ] }
                var subscription = [ "REQ", subId, filter ];
                socket.send(JSON.stringify( subscription ));
            }
            var loadFundraiser = async () => {
                $( '.welcome_page' ).classList.add( "hidden" );
                $( '.project' ).classList.remove( "hidden" );
                $( '.project' ).innerHTML = '<div class="countdown_div">loading...</div>';
                var split_b64 = await downloader( $_GET[ "fundraiser" ] );
                if ( split_b64 == "no good" ) return showModal( `Could not load fundraiser, try again` );
                project = JSON.parse( atob( split_b64.split( "|---|" )[ 1 ] ) );
                project[ "project_pic" ] = split_b64.split( "|---|" )[ 0 ];
                if ( !isValidAddress( project.project_add ) ) return showModal( `Invalid fundraiser due to bad bitcoin address` );
                //TODO: uncomment the line below
                // if ( $( '.project_add' ).value.startsWith( "t" ) || $( '.project_add' ).value.startsWith( "r" ) || $( '.project_add' ).value.startsWith( "m" ) || $( '.project_add' ).value.startsWith( "n" ) || $( '.project_add' ).value.startsWith( "2" ) ) return showModal( `Try again with a mainnet bitcoin address` );
                if ( typeof project.project_gol != "number" ) return showModal( `Invalid fundraiser due to bad goal` );
                if ( typeof project.project_end != "number" ) return showModal( `Invalid fundraiser due to bad end date` );
                used_txid_and_vouts = [];
                contributed_utxos = [];
                if ( $( '.raised' ) ) {
                    $( '.raised' ).innerText = 0;
                    $( '.percent_funded' ).innerText = '0%';
                    $( '.num_of_pledgers' ).innerText = 0;
                    $( '.comments_bottom' ).innerHTML = `<p class="comments_label hidden">Comments</p>`;
                    $( '.column_right' ).innerHTML = `<p class="comments_label hidden">Comments</p>`;
                }
                await loadProject( project );
                var hex_id = nostr_image_host.bech32ToHex( $_GET[ "fundraiser" ] );
                relay = nostr_image_host.hexToText( hex_id.substring( 64 ) );
                fundraiser_addy = project.project_add;
                lastblock = await getBlockheight( "" );
                socket = new WebSocket( relay );
                socket.addEventListener( 'message', processContrib );
                socket.addEventListener( 'open', getContribs );
            }
            var spendCoins = async ( destino, sats_per_byte ) => {
                var script = [ 0, btc_pub, 'OP_CHECKSIGADD', project.project_key, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ];
                var tapleaf = tapscript.Tap.encodeScript( script );
                var [ tseckey_keypath ] = tapscript.Tap.getSecKey( btc_sec, { tree: [script].map( s => tapscript.Tap.encodeScript( s ) ) } );
                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey( btc_pub, { target: tapleaf });
                var from_address = tapscript.Address.p2tr.fromPubKey( tpubkey, mainnet_or_testnet );
                var inputs = [];
                var outputs = [];
                var from_amount = 0;
                contributor_utxos.forEach( utxo => {
                    from_amount = from_amount + utxo[ "value" ];
                    var txid = utxo[ "txid" ];
                    var vout = utxo[ "vout" ];
                    var amount = utxo[ "value" ];
                    inputs.push({
                        txid: txid,
                        vout: vout,
                        prevout: {
                            value: amount,
                            scriptPubKey: tapscript.Address.toScriptPubKey( from_address ),
                        },
                    });
                });
                //I assume the txsize begins as 4 bytes for the version number, 4
                //bytes for the locktime, 1 byte for the size of the witness script,
                //1 byte for the size of the locking script, 1 byte for the size
                //of the pubkey in the locking script, and 1 byte for OP_0 or OP_1
                //preceding the output script
                var txsize = 12;
                //I calculate that inputs add 65 bytes for the sig, 35 bytes for
                //the txid, and 5 bytes for the vout (remembering that each one
                //is preceded by a byte that indicates how long that string is)
                inputs.forEach( item => txsize = txsize + 65 + 33 + 5 );
                //I calculate that outputs add 41 bytes apiece by
                //assuming the average scriptpubkey is 33 bytes
                //and assuming amounts are denoted in 8 bytes
                txsize = txsize + 41;
                var mining_fee = txsize * sats_per_byte;
                if ( mining_fee < 172 ) mining_fee = 172;
                var to_amount = from_amount - mining_fee;
                var there_be_dust = false;
                outputs.push({
                    value: to_amount,
                    scriptPubKey: tapscript.Address.toScriptPubKey( destino ),
                });
                if ( to_amount < 546 ) there_be_dust = true;
                if ( there_be_dust ) return showModal( `You tried to send ${from_amount} sats but the mining fee was ${mining_fee} sats, which leaves a leftover amount of ${to_amount} sats -- lower than bitcoin's dust limit. You cannot send an amount that small. Please make a bigger deposit and try again.` );
                var txdata = tapscript.Tx.create({
                    vin  : inputs,
                    vout : outputs,
                });
                contributor_utxos.forEach( ( utxo, index ) => {
                    var sig = tapscript.Signer.taproot.sign( tseckey_keypath, txdata, index );
                    txdata.vin[ index ].witness = [ sig ];
                });
                var txhex = tapscript.Tx.encode( txdata ).hex;
                var txid = await pushBTCpmt( txhex, '' );
                if ( txid.includes( 'error' ) ) return showModal( '<p>Oh no! There was an error with your transaction, please try again. Here is the error message:</p><p>' + txid + '</p><p>Ask a developer for help.</p>' );
                showModal( `Success! Here is your txid: <a href="https://${btc_net}/tx/${txid}" target="_blank">https://${btc_net}/tx/${txid}</a>` );
            }
            async function getThreeFeeRates( network ) {
                var fees = await getData(`https://${btc_net}/` + network + "api/v1/fees/recommended");
                fees = JSON.parse(fees);
                var array = [ fees["minimumFee"], fees["hourFee"], fees["fastestFee"] ];
                return array;
            }
            var showIrreversible = async () => {
                if ( project.project_lna ) {
                    var skip_ln_invoice = false;
                    var lnaddress = project.project_lna;
                    var split_lna = lnaddress.split( "@" );
                    var domain = split_lna[ 1 ];
                    var username = split_lna[ 0 ];
                    var url = `https://${domain}/.well-known/lnurlp/${username}`;
                    try {
                        var ln_info = await getData( url );
                        ln_info = JSON.parse( ln_info );
                    } catch( e ) {
                        skip_ln_invoice = true;
                    }
                    if ( !skip_ln_invoice ) {
                        var minSendable = ln_info[ "minSendable" ];
                        var maxSendable = ln_info[ "maxSendable" ];
                        var callback = ln_info[ "callback" ];
                        var second_url = `${callback}?amount=${minSendable}`;
                        try {
                            var invoice_info = await getData( second_url );
                            invoice_info = JSON.parse( invoice_info );
                            var invoice = invoice_info[ "pr" ];
                            if ( !invoice ) throw "didn't work";
                            else lightning_works = true;
                        } catch( e ) {
                            var invoice = "didn't work";
                        }
                        if ( invoice == "didn't work" ) skip_ln_invoice = true;
                    }
                }
                var address = fundraiser_addy;
                var url = "bitcoin:" + address;
                var a = document.createElement( "a" );
                a.href = url;
                a.target = "_blank";
                a.append( createQR( url.toUpperCase() ) );
                var prep_div = document.createElement( "div" );
                var html = ``;
                if ( lightning_works ) html += `<p><span style="color: blue; text-decoration: underline; cursor: pointer" onclick="doLightning( ${minSendable}, ${maxSendable} )">Click here</span> to contribute via lightning</p>`;
                if ( lightning_works ) html += `<p>Otherwise send your contribution here</p>`;
                else html += `<p>Please send your contribution here</p>`;
                prep_div.innerHTML = html;
                prep_div.append( a );
                var div_html = prep_div.innerHTML + `<p>${address}</p>`;
                showModal( div_html );
                var utxos = await getData( `https://${btc_net}/api/address/${address}/utxo` );
                utxos = JSON.parse( utxos );
                var simplified_utxos = [];
                utxos.forEach( item => simplified_utxos.push( `${item[ "txid" ]}:${item[ "vout" ]}` ) );
                var new_utxo = await utxoloop( address, simplified_utxos );
                var txid_vout_amt = new_utxo.split( ":" );
                var txid = txid_vout_amt[ 0 ];
                var vout = Number( txid_vout_amt[ 1 ] );
                var amt = Number( txid_vout_amt[ 2 ] );
                showModal( `
                    <p>Someone just contributed ${amt} sats. Was that you?</p><p><button class="yes_was_me" onclick="irreversibleSuccess( '${txid}', '${vout}' );">Yes</button><button class="no_not_me" onclick="showIrreversible();">No</button></p>
                ` );
            }
            var irreversibleSuccess = async ( txid, vout ) => {
                sessionStorage.removeItem( "modal_cleared" );
                sessionStorage.removeItem( "comment" );
                showModal( `
                    <p style="font-weight: bold;">Pledge detected! Enter a public comment to send with it (optional)</p>
                    <p><input style="max-width: 90%" class="modal_comment"></p>
                    <p>Chars left: <span class="modal_comment_chars_left">140</span></p>
                    <p><button class="submit_modal_comment" onclick="sessionStorage[ 'comment' ] = $( '.modal_comment' ).value;sessionStorage[ 'modal_cleared' ] = true;showModal( '<p>loading...</p>' );">Submit</button></p>
                `, true );
                $( '.modal_comment' ).onchange = () => {
                    var text = $( '.modal_comment' ).value;
                    var limit = 140;
                    var length = text.length;
                    if ( limit - length < 0 ) return $( '.modal_comment' ).value = text.substring( 0, limit );
                    $( '.modal_comment_chars_left' ).innerText = `${limit - length}`;
                }
                $( '.modal_comment' ).onkeyup = () => {
                    var text = $( '.modal_comment' ).value;
                    var limit = 140;
                    var length = text.length;
                    if ( limit - length < 0 ) return $( '.modal_comment' ).value = text.substring( 0, limit );
                    $( '.modal_comment_chars_left' ).innerText = `${limit - length}`;
                }
                await getNote( "modal_cleared" );
                var comment = await getNote( "comment" );
                sessionStorage.removeItem( "comment" );
                var privKey = nostr_image_host.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var pubKey = nobleSecp256k1.getPublicKey( privKey, true ).substring( 2 );
                var note = JSON.stringify({
                    fundraiser_id: $_GET[ "fundraiser" ],
                    is_lightning: false,
                    txid,
                    vout,
                    public_comment: comment,
                });
                if ( socket.readyState != 1 ) {
                    socket = new WebSocket( relay );
                    socket.addEventListener('open', async function() {
                        var event = {
                            "content"    : note,
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"       : 62116,
                            "tags"       : [ [ "p", project.project_key ] ],
                            "pubkey"     : pubKey,
                        }
                        var signedEvent = await nostr_image_host.getSignedEvent( event, privKey );
                        socket.send( JSON.stringify([ "EVENT", signedEvent ]) );
                        await nostr_image_host.waitSomeSeconds( 2 );
                        socket.close();
                        showModal( '<p>Success! Your contribution has been recorded</p>' );
                    });
                } else {
                    var event = {
                        "content"    : note,
                        "created_at" : Math.floor( Date.now() / 1000 ),
                        "kind"       : 62116,
                        "tags"       : [ [ "p", project.project_key ] ],
                        "pubkey"     : pubKey,
                    }
                    var signedEvent = await nostr_image_host.getSignedEvent( event, privKey );
                    socket.send( JSON.stringify([ "EVENT", signedEvent ]) );
                    await nostr_image_host.waitSomeSeconds( 2 );
                    socket.close();
                    showModal( '<p>Success! Your contribution has been recorded</p>' );
                }
            }
            var do_upload_bar = async ( hash, image_id ) => {
                var html = `
                    <div class="progress">
                        <h2>Progress bar <span id="goal" style="font-size: .8em; font-weight: normal;"></span></h2>
                        <div class="progressOutline" style="height: 2em; border: 1px solid grey; border-radius: 25px; overflow: hidden;">
                            <div class="progressBar" style="height: 2em; background-color: #61eb34; width: 0%; transition: width 1s;">
                            </div>
                        </div>
                        <div class="progress_status"></div>
                    </div>
                `;
                if ( nostr_image_host[ `n_${hash}_percent_done_uploading` ] == "100%" ) html = html + `<h2>Your image id</h2><p>${image_id}</p>`;
                showModal( html );
                var percent = nostr_image_host[ `n_${hash}_percent_done_uploading` ];
                if ( $( '.progressBar' ) ) $( '.progressBar' ).style.width = percent;
                await nostr_image_host.waitSomeSeconds( 2 );
                if ( nostr_image_host[ `n_${hash}_percent_done_uploading` ] != "100%" ) do_upload_bar( hash );
            }
            function isValidAddress( address ) {
                try{
                    return !!tapscript.Address.decode( address ).script;
                } catch( e ) {return;}
                return;
            }
            var specialDeposit = async ( amount_needed, goal_level ) => {
                var inputs = [];
                var script = [ 0, btc_pub, 'OP_CHECKSIGADD', btc_pub, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ];
                var tapleaf = tapscript.Tap.encodeScript( script );
                var [ tseckey_keypath ] = tapscript.Tap.getSecKey( btc_sec, { tree: [script].map( s => tapscript.Tap.encodeScript( s ) ) } );
                // var [ tseckey_script_path ] = tapscript.Tap.getSecKey( btc_sec, { tree: [script].map( s => tapscript.Tap.encodeScript( s ) ), target: tapleaf });
                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey( btc_pub, { target: tapleaf });
                var address = tapscript.Address.p2tr.fromPubKey( tpubkey, mainnet_or_testnet );
                var url = "bitcoin:" + address;
                var a = document.createElement( "a" );
                a.href = url;
                a.target = "_blank";
                a.append( createQR( url.toUpperCase() ) );
                var prep_div = document.createElement( "div" );
                prep_div.append( a );
                var div_html = prep_div.innerHTML + `<p>${address}</p><p>Please deposit EXACTLY ${amount_needed} sats -- if you deposit ANYTHING EXTRA it will go to miners as fees</p>`;
                showModal( div_html );
                var utxos = await getData( `https://${btc_net}/api/address/${address}/utxo` );
                utxos = JSON.parse( utxos );
                var simplified_utxos = [];
                utxos.forEach( item => simplified_utxos.push( `${item[ "txid" ]}:${item[ "vout" ]}` ) );
                var new_utxo = await utxoloop( address, simplified_utxos );
                new_utxo = new_utxo.split( ":" );
                var utxos_to_block = [];
                var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                    var item = contributed_utxos[ i ];
                    var index = i;
                    var input = {
                        txid: item[ "txid" ],
                        vout: item[ "vout" ],
                        prevout: {
                            value: item[ "value" ],
                            scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                        }
                    }
                    if ( `num_${levels[ goal_level ]}` in item[ "levels_with_valid_sig" ] ) {
                        var sig = item[ "levels_with_valid_sig" ][ `num_${levels[ goal_level ]}` ];
                        input.witness = [ sig ];
                        inputs.push( input );
                    }
                    else {
                        utxos_to_block.push( i );
                        continue;
                    }
                }
                var last_input = {
                    txid: new_utxo[ 0 ],
                    vout: Number( new_utxo[ 1 ] ),
                    prevout: {
                        value: Number( new_utxo[ 2 ] ),
                        scriptPubKey: tapscript.Address.toScriptPubKey( address ),
                    }
                }
                inputs.push( last_input );
                var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                    var item = contributed_utxos[ i ];
                    var index = i;
                    if ( utxos_to_block.includes( index ) ) continue;
                    var contribution_txdata = tapscript.Tx.create({
                        vin: inputs,
                        vout: [{
                            value: levels[ goal_level ],
                            scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                        }],
                    });
                    var tapleaf = item[ "tapleaf" ];
                    var script = item[ "script" ];
                    var cblock = item[ "cblock" ];
                    var their_key = item[ "contributor_key" ];
                    var their_sig = contribution_txdata.vin[ index ].witness[ 0 ];
                    var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                    var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                    var mysig = tapscript.Signer.taproot.sign( btc_sec, contribution_txdata, index, { extension: tapleaf } ).hex;
                    if ( !isValid ) {
                        contribution_txdata.vin.splice( i, 1 );
                        continue;
                    }
                    contribution_txdata.vin[ index ].witness.unshift( mysig );
                    contribution_txdata.vin[ index ].witness.push( script, cblock );
                    // if ( i == contributed_utxos.length - 1 ) console.log( "contribution_txdata:", JSON.stringify( contribution_txdata ) );
                }
                var last_sig = tapscript.Signer.taproot.sign( tseckey_keypath, contribution_txdata, contribution_txdata.vin.length - 1 ).hex;
                contribution_txdata.vin[ contribution_txdata.vin.length - 1 ].witness = [ last_sig ];
                var txhex = tapscript.Tx.encode( contribution_txdata ).hex;
                // console.log( txhex );
                var txid = await pushBTCpmt( txhex, '' );
                if ( txid.includes( 'error' ) ) return showModal( '<p>Oh no! There was an error with your transaction, please try again. Here is the error message:</p><p>' + txid + '</p><p>Ask a developer for help.</p>' );
                showModal( `Success! Here is your txid: <a href="https://${btc_net}/tx/${txid}" target="_blank">https://${btc_net}/tx/${txid}</a>` );
            }
            async function pushBTCpmt( rawtx, network ) {
                var txid = await postData( `https://${btc_net}/` + network + "api/tx", rawtx );
                return txid;
            }
            async function getBitcoinPriceFromCoinbase() {
                var data = await getData( "https://api.coinbase.com/v2/prices/BTC-USD/spot" );
                if ( data == "error" ) return 0;
                var json = JSON.parse( data );
                var price = json[ "data" ][ "amount" ];
                return price;
            }

            async function getBitcoinPriceFromKraken() {
                var data = await getData( "https://api.kraken.com/0/public/Ticker?pair=XBTUSD" );
                if ( data == "error" ) return 0;
                var json = JSON.parse( data );
                var price = json[ "result" ][ "XXBTZUSD" ][ "a" ][ 0 ];
                return price;
            }

            async function getBitcoinPriceFromCoindesk() {
                var data = await getData( "https://api.coindesk.com/v1/bpi/currentprice.json" );
                if ( data == "error" ) return 0;
                var json = JSON.parse( data );
                var price = json[ "bpi" ][ "USD" ][ "rate_float" ];
                return price;
            }

            async function getBitcoinPriceFromGemini() {
                var data = await getData( "https://api.gemini.com/v2/ticker/BTCUSD" );
                if ( data == "error" ) return 0;
                var json = JSON.parse( data );
                var price = json[ "bid" ];
                return price;
            }

            async function getBitcoinPriceFromCoinGecko() {
                var data = await getData( "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&precision=2" );
                if ( data == "error" ) return 0;
                var json = JSON.parse( data );
                var price = json[ "bitcoin" ][ "usd" ];
                return price;
            }

            async function getBitcoinPrice() {
                var prices = [];
                var cbprice = await getBitcoinPriceFromCoinbase();
                var kprice = await getBitcoinPriceFromKraken();
                var cdprice = await getBitcoinPriceFromCoindesk();
                var gprice = await getBitcoinPriceFromGemini();
                var cgprice = await getBitcoinPriceFromCoinGecko();
                prices.push( Number( cbprice ), Number( kprice ), Number( cdprice ), Number( gprice ), Number( cgprice ) );
                prices.sort();
                return prices[ 2 ];
            }
            var bitcoinToSats = btc => Math.floor( btc * 100_000_000 );

            async function satsToDollars( sats ) {
                if ( sats >= 100000000 ) sats = sats * 10;
                if ( !sessionStorage[ "btc_price" ] ) var bitcoin_price = await getBitcoinPrice();
                else var bitcoin_price = Number( sessionStorage[ "btc_price" ] );
                var value_in_dollars = Number( String( sats ).padStart( 8, "0" ).slice( 0,-9 ) + "." + String( sats ).padStart( 8, "0" ).slice( -9 ) ) * bitcoin_price;
                return value_in_dollars;
            }

            async function postData( url, json, content_type = "", apikey = "" ) {
                var rtext = "";
                function inner_post( url, json, content_type = "", apikey = "" ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "POST", url, true );
                    if ( content_type ) {
                        xhttp.setRequestHeader( `Content-Type`, content_type );
                    }
                    if ( apikey ) {
                        xhttp.setRequestHeader( `X-Api-Key`, apikey );
                    }
                    xhttp.send( json );
                    return xhttp;
                }
                var data = inner_post( url, json, content_type, apikey );
                data.onerror = function( e ) {
                    rtext = "error";
                }
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( rtext == "error" ) {
                            resolve( rtext );
                        }
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve( msg );
                            }, 50 );
                        } else {
                            resolve( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }
            var checkForUtxos = async () => {
                var script = [ 0, btc_pub, 'OP_CHECKSIGADD', project.project_key, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ];
                var tapleaf = tapscript.Tap.encodeScript( script );
                var [ tseckey_keypath ] = tapscript.Tap.getSecKey( btc_sec, { tree: [script].map( s => tapscript.Tap.encodeScript( s ) ) } );
                // var [ tseckey_script_path ] = tapscript.Tap.getSecKey( btc_sec, { tree: [script].map( s => tapscript.Tap.encodeScript( s ) ), target: tapleaf });
                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey( btc_pub, { target: tapleaf });
                var address = tapscript.Address.p2tr.fromPubKey( tpubkey, mainnet_or_testnet );
                var utxos = await getData( `https://${btc_net}/api/address/${address}/utxo` );
                contributor_utxos = JSON.parse( utxos );
                if ( contributor_utxos.length ) $( '.revoke_button' ).classList.remove( "hidden" );
            }
            var prepLevels = async () => {
                levels = [];
                var i; for ( i=0; i<901; i++ ) {
                    var ten_percent = Math.floor( ( project.project_gol * .01 ) );
                    var extra = ten_percent * i;
                    levels.push( project.project_gol + extra );
                }
                var contribution_txdata = tapscript.Tx.create({
                    vin: [],
                    vout: [{
                        value: 0,
                        scriptPubKey: tapscript.Address.toScriptPubKey( project.project_add ),
                    }],
                });
                showModal( `
                    <p>Preparing to claim funds</p>
                    <h2>Progress bar (1/2) <span id="goal" style="font-size: .8em; font-weight: normal;"></span></h2>
                    <div class="progressOutline" style="height: 2em; border: 1px solid grey; border-radius: 25px; overflow: hidden;">
                        <div class="progressBar" style="height: 2em; background-color: #61eb34; width: 0%; transition: width 1s;">
                        </div>
                    </div>
                    <div class="status">Downloading signatures</div>
                ` );
                var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                    var item = contributed_utxos[ i ];
                    var index = i;
                    var b64 = await downloader( item[ "extra_sigs_id" ] )
                    if ( b64 == "no good" ) continue;
                    var hex = base64ToHex( b64 );
                    var sigs_array = hex.match(/.{1,130}/g);
                    downloaded_sigs[ `${item[ "txid" ]}${item[ "vout" ]}` ] = sigs_array;
                    sigs_array.unshift( item[ "main_sigs" ][ 1 ] );
                    var percent = Number( ( ( Number( i + 1 ) / contributed_utxos.length ) * 100 ).toFixed( 2 ) );
                    if ( $( '.progressBar' ) ) $( '.progressBar' ).style.width = String( percent ) + "%";
                    if ( percent > 99 ) await nostr_image_host.waitSomeSeconds( 1 );
                }
                var valid_levels = [];
                var j; for ( j=0; j<levels.length; j++ ) {
                    var percent = Number( ( ( Number( j + 1 ) / levels.length ) * 100 ).toFixed( 2 ) );
                    showModal( `
                        <p>Preparing to claim funds</p>
                        <h2>Progress bar (2/2) <span id="goal" style="font-size: .8em; font-weight: normal;"></span></h2>
                        <div class="progressOutline" style="height: 2em; border: 1px solid grey; border-radius: 25px; overflow: hidden;">
                            <div class="progressBar" style="height: 2em; background-color: #61eb34; width: ${percent}%; transition: width 1s;">
                            </div>
                        </div>
                        <div class="status">Validating signatures</div>
                    ` );
                    contribution_txdata.vin = [];
                    var amt_contributed_for_this_level = 0;
                    var i; for ( i=0; i<contributed_utxos.length; i++ ) {
                        var item = contributed_utxos[ i ];
                        var index = i;
                        var input = {
                            txid: item[ "txid" ],
                            vout: item[ "vout" ],
                            prevout: {
                                value: item[ "value" ],
                                scriptPubKey: tapscript.Address.toScriptPubKey( item[ "address" ] ),
                            }
                        }
                        input.witness = [];
                        var sigs_array = downloaded_sigs[ `${item[ "txid" ]}${item[ "vout" ]}` ];
                        var their_sig = sigs_array[ j ];
                        input.witness = [ their_sig ];
                        contribution_txdata.vin[ index ] = input;
                        contribution_txdata.vout[ 0 ][ "value" ] = levels[ j ];
                        var tapleaf = item[ "tapleaf" ];
                        var script = item[ "script" ];
                        var cblock = item[ "cblock" ];
                        var their_key = item[ "contributor_key" ];
                        var sighash = await tapscript.Signer.taproot.hash( contribution_txdata, index, { extension: tapleaf, sigflag: 128 | 1 } ).hex;
                        var isValid = await nobleSecp256k1.schnorr.verify( their_sig.substring( 0, 128 ), sighash, their_key );
                        if ( !isValid ) continue;
                        amt_contributed_for_this_level = amt_contributed_for_this_level + item[ "value" ];
                        contributed_utxos[ i ][ "levels_with_valid_sig" ][ `num_${levels[ j ]}` ] = their_sig;
                    }
                    if ( amt_contributed_for_this_level >= levels[ j ] ) valid_levels.push( levels[ j ] );
                }
                var next_level;
                levels.every( item => {
                    if ( item > valid_levels[ valid_levels.length - 1 ] ) {
                        next_level = item;
                        return;
                    }
                    return true;
                });
                if ( next_level ) valid_levels.push( next_level );
                levels = valid_levels;
                if ( !levels.length ) levels.push( project.project_gol );
            }
            var downloader = async file_id => {
                var b64;
                setTimeout( () => {b64 = "no good"}, 5000 );
                setTimeout( async () => {b64 = await nostr_image_host.downloadFromNostr( file_id );}, 1 );
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( b64 );
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( b64 );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }
            var broadcastAndShowModal = async txhex => {
                var txid = await pushBTCpmt( txhex, '' );
                if ( txid.includes( 'error' ) ) return showModal( '<p>Oh no! There was an error with your transaction, please try again. Here is the error message:</p><p>' + txid + '</p><p>Ask a developer for help.</p>' );
                showModal( `Success! Here is your txid: <a href="https://${btc_net}/tx/${txid}" target="_blank">https://${btc_net}/tx/${txid}</a>` );
            }
            var doLightning = async ( minSendable, maxSendable ) => {
                sessionStorage.removeItem( "ln_amount" );
                sessionStorage.removeItem( "modal_cleared" );
                showModal( `
                    <p style="font-weight: bold;">Enter the amount of sats you want to send via lightning</p>
                    <p><input type="number" style="max-width: 90%" class="ln_amount"></p>
                    <p><button class="submit_ln_amount" onclick="sessionStorage[ 'ln_amount' ] = $( '.ln_amount' ).value;sessionStorage[ 'modal_cleared' ] = true;">Submit</button></p>
                `, true );
                await getNote( "modal_cleared" );
                sessionStorage.removeItem( "modal_cleared" );
                var ln_amount = await getNote( "ln_amount" );
                ln_amount = Number( ln_amount );
                ln_amount = ln_amount * 1000;
                sessionStorage.removeItem( "ln_amount" );
                if ( ln_amount > Math.floor( maxSendable / 1000 ) ) return showModal( `The amount you entered is more than ${Math.floor( maxSendable / 1000 ).toLocaleString()} sats, the maximum amount allowed by the fundraiser's lightning address server. Please try again and contribute a smaller amount.` );
                if ( ln_amount < Math.floor( minSendable / 1000 ) ) return showModal( `The amount you entered is lower than ${Math.floor( minSendable / 1000 ).toLocaleString()} sats, the minimum amount allowed by the fundraiser's lightning address server. Please try again and contribute a larger amount.` );
                sessionStorage.removeItem( "ln_public" );
                if ( !project.has_verify ) {
                    showModal( `
                        <p style="font-weight: bold;">Public or private?</p>
                        <p>This software cannot "look up" your lightning payment like it can with a "regular" bitcoin payment because lightning payments are private by design and therefore are not recorded on a public blockchain. But a crowdfund, as the name implies, is meant to be public. So you have to do a bit of work if you want your lightning pledge publicly registered as a contribution the crowdfund.</p>
                        <p>Lightning payments are "proven" with something called a "preimage" or a "proof of payment" which functions as a sort of receipt. To "publish" your contribution you must provide this preimage after you make your payment, but not all lightning wallets show it to you.</p>
                        <p>If you want your contribution to be public, first ensure your wallet shows this preimage to you when you make a payment. (Try making a small payment to some other service, then view the transaction details, then look for something called a "preimage" or a "proof of payment.") You will be asked to paste it on the next page after you make the payment.</p>
                        <p>Or you can decide *not* to publish this payment. If you choose that option, the recipient will still get the money but it won't count toward the fundraising goal. What do you want to do?</p>
                        <p><button class="ln_public" onclick="sessionStorage[ 'ln_public' ] = true;sessionStorage[ 'modal_cleared' ] = true;">Public</button> <button class="ln_private" onclick="sessionStorage[ 'modal_cleared' ] = true;">Private</button></p>
                    `, true );
                    await getNote( "modal_cleared" );
                    sessionStorage.removeItem( "modal_cleared" );
                    var payment_is_public;
                    if ( sessionStorage[ "ln_public" ] ) payment_is_public = true;
                    sessionStorage.removeItem( "ln_public" );                    
                } else {
                    var payment_is_public = true;
                }
                var lnaddress = project.project_lna;
                var split_lna = lnaddress.split( "@" );
                var domain = split_lna[ 1 ];
                var username = split_lna[ 0 ];
                var url = `https://${domain}/.well-known/lnurlp/${username}`;
                var ln_info = await getData( url );
                ln_info = JSON.parse( ln_info );
                var callback = ln_info[ "callback" ];
                var second_url = `${callback}?amount=${ln_amount}`;
                var invoice_info = await getData( second_url );
                invoice_info = JSON.parse( invoice_info );
                if ( "verify" in invoice_info ) var verify_url = invoice_info[ "verify" ];
                var invoice = invoice_info[ "pr" ];
                var url = "lightning:" + invoice;
                var a = document.createElement( "a" );
                a.href = url;
                a.target = "_blank";
                a.append( createQR( url.toUpperCase() ) );
                var prep_div = document.createElement( "div" );
                var html = `<p>Please send your contribution here</p>`;
                prep_div.innerHTML = html;
                prep_div.append( a );
                var more_html = ``;
                if ( payment_is_public && !project.has_verify ) {
                    more_html += `
                        <p>Please paste the preimage here</p>
                        <p><input style="max-width: 90%" class="ln_preimage"></p>
                        <p><button class="submit_ln_preimage" onclick="sessionStorage[ 'ln_preimage' ] = $( '.ln_preimage' ).value;sessionStorage[ 'modal_cleared' ] = true;">Submit</button></p>`
                }
                more_html += `<p>Your lightning invoice:</p><p>${invoice}</p>`;
                var div_html = prep_div.innerHTML + more_html;
                showModal( div_html );
                if ( !payment_is_public ) return;
                if ( !project.has_verify ) await getNote( "modal_cleared" );
                else await checkVerifyOnLoop( verify_url );
                sessionStorage.removeItem( "modal_cleared" );
                $( '.x_modal' ).click();
                if ( !project.has_verify ) var ln_preimage = sessionStorage[ "ln_preimage" ];
                else var ln_preimage = verify_url;
                if ( !project.has_verify ) {
                    sessionStorage.removeItem( "ln_preimage" );
                    var expected_pmthash = getInvoicePmthash( invoice );
                    var real_pmthash = SHA256( nostr_image_host.hexToBytes( ln_preimage ) );
                    var they_match = expected_pmthash == real_pmthash;
                    if ( !they_match ) return showModal( `It looks like you pasted your preimage wrong -- for some reason, it did not match the invoice. The recipient still got your money but I'm sorry to say your contribution won't count toward the fundraising goal.` );
                }
                sessionStorage.removeItem( "modal_cleared" );
                sessionStorage.removeItem( "comment" );
                showModal( `
                    <p style="font-weight: bold;">Pledge detected! Enter a public comment to send with it (optional)</p>
                    <p><input style="max-width: 90%" class="modal_comment"></p>
                    <p>Chars left: <span class="modal_comment_chars_left">140</span></p>
                    <p><button class="submit_modal_comment">Submit</button></p>
                `, true );
                $( '.submit_modal_comment' ).onclick = () => {
                    sessionStorage[ 'comment' ] = $( '.modal_comment' ).value;
                    sessionStorage[ 'modal_cleared' ] = true;
                    showModal( `<p>loading, please wait...</p>` );
                }
                $( '.modal_comment' ).onchange = () => {
                    var text = $( '.modal_comment' ).value;
                    var limit = 140;
                    var length = text.length;
                    if ( limit - length < 0 ) return $( '.modal_comment' ).value = text.substring( 0, limit );
                    $( '.modal_comment_chars_left' ).innerText = `${limit - length}`;
                }
                $( '.modal_comment' ).onkeyup = () => {
                    var text = $( '.modal_comment' ).value;
                    var limit = 140;
                    var length = text.length;
                    if ( limit - length < 0 ) return $( '.modal_comment' ).value = text.substring( 0, limit );
                    $( '.modal_comment_chars_left' ).innerText = `${limit - length}`;
                }
                await getNote( "modal_cleared" );
                var comment = await getNote( "comment" );
                sessionStorage.removeItem( "comment" );
                var note = JSON.stringify({
                    fundraiser_id: $_GET[ "fundraiser" ],
                    is_lightning: true,
                    invoice,
                    preimage: ln_preimage,
                    public_comment: comment,
                });
                var fundraiser_key = project.project_key;
                var privKey = nostr_image_host.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var pubKey = nobleSecp256k1.getPublicKey( privKey, true ).substring( 2 );
                var event = {
                    "content"    : note,
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"       : 62116,
                    "tags"       : [ [ "p", fundraiser_key ] ],
                    "pubkey"     : pubKey,
                }
                var signedEvent = await nostr_image_host.getSignedEvent( event, privKey );
                socket.send( JSON.stringify([ "EVENT", signedEvent ]) );
                await nostr_image_host.waitSomeSeconds( 2 );
                socket.close();
                var html = `<p>Success! Your contribution has been recorded</p>`;
                showModal( html );
            }
            var SHA256 = string_or_uint8array => nostr_image_host.bytesToHex( sha256( string_or_uint8array ) );
            var isValidInvoice = invoice => {
                try{
                    return typeof bolt11.decode( invoice ) == "object";
                } catch( e ) {
                    return;
                }
            }
            function getInvoiceAmount( invoice ) {
                var decoded = bolt11.decode( invoice );
                var amount = decoded[ "satoshis" ].toString();
                return Number( amount );
            }
            function getInvoicePubkey( invoice ) {
                var decoded = bolt11.decode( invoice );
                return decoded.payeeNodeKey;
            }
            var getInvoicePmthash = invoice => {
                var decoded = bolt11.decode( invoice );
                var i; for ( i=0; i<decoded[ "tags" ].length; i++ ) {
                    if ( decoded[ "tags" ][ i ][ "tagName" ] == "payment_hash" ) var pmthash = decoded[ "tags" ][ i ][ "data" ].toString();
                }
                return pmthash;
            }
            var getInvoiceDeschash = invoice => {
                var deschash = "no desc hash";
                var decoded = bolt11.decode( invoice );
                var i; for ( i=0; i<decoded[ "tags" ].length; i++ ) {
                    if ( decoded[ "tags" ][ i ][ "tagName" ] == "purpose_commit_hash" ) var deschash = decoded[ "tags" ][ i ][ "data" ].toString();
                }
                return deschash;
            }
            function isValidHex( h ) {
                if ( !h ) return;
                var length = h.length;
                if ( length % 2 ) return;
                try {
                    var a = BigInt( "0x" + h, "hex" );
                } catch( e ) {
                    return;
                }
                var unpadded = a.toString( 16 );
                var padding = [];
                var i; for ( i=0; i<length; i++ ) padding.push( 0 );
                padding = padding.join( "" );
                padding = padding + unpadded.toString();
                padding = padding.slice( -Math.abs( length ) );
                return ( padding === h );
            }
            var convertSecToDer = sec_sig => {
                var sig_parts = sec_sig.match( /.{64}/g );
                var part_one_array = sig_parts[ 0 ].match( /.{2}/g );
                var index_of_non_zeros_in_first_part = 0;
                part_one_array.every( ( item, index ) => {
                    if ( item != "00" ) {
                        index_of_non_zeros_in_first_part = index;
                        return;
                    }
                    return true;
                });
                part_one_array.splice( 0, index_of_non_zeros_in_first_part );
                sig_parts[ 0 ] = part_one_array.join( "" );
                var part_two_array = sig_parts[ 1 ].match( /.{2}/g );
                var index_of_non_zeros_in_second_part = 0;
                part_two_array.every( ( item, index ) => {
                    if ( item != "00" ) {
                        index_of_non_zeros_in_second_part = index;
                        return;
                    }
                    return true;
                });
                part_two_array.splice( 0, index_of_non_zeros_in_second_part );
                sig_parts[ 1 ] = part_two_array.join( "" );
                var part_one_length = ( sig_parts[ 0 ].length / 2 ).toString( 16 );
                var part_two_length = ( sig_parts[ 1 ].length / 2 ).toString( 16 );
                var part_one_prefix = "02" + part_one_length;
                var part_two_prefix = "02" + part_two_length;
                var overall_length = ( ( sig_parts[ 0 ].length / 2 ) + 2 + ( sig_parts[ 1 ].length / 2 ) + 2 ).toString( 16 );
                var der_sig = `30${overall_length}${part_one_prefix}${sig_parts[ 0 ]}${part_two_prefix}${sig_parts[ 1 ]}`;
                return der_sig;
            }
            var checkVerifyOnLoop = async url => {
                var settlement_info = await getData( url );
                settlement_info = JSON.parse( settlement_info );
                var settled = settlement_info[ "settled" ];
                if ( settled ) return true;
                await nostr_image_host.waitSomeSeconds( 2 );
                var test = await checkVerifyOnLoop( url );
                return test;
            }
        </script>
    </head>
    <body>
        <div class="all_container">
            <div class="navbar_container">
                <div class="navbar">
                    <a href="https://semaphore.finance/" style="color: black; text-decoration: none;">
                        <div class="logo_name_and_desc">
                            <div class="semaphore_logo">
                                <img class="logo_image">
                                <script>
                                    var img = ` data:image/png;base64,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ICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6cGx1cz0iaHR0cDovL25zLnVzZXBsdXMub3JnL2xkZi94bXAvMS4wLyIKICAgIHhtbG5zOkdJTVA9Imh0dHA6Ly93d3cuZ2ltcC5vcmcveG1wLyIKICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICB4bXBNTTpEb2N1bWVudElEPSJnaW1wOmRvY2lkOmdpbXA6NTlkY2YyNTMtYTk4MC00ZWRiLTgzYjEtODhmMWYwNGNiZGI4IgogICB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjQ4YzZjNDllLTY4OGEtNDI1OS1hZDMzLTdmOGYxMzA2YmQ0ZCIKICAgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjM2ZTFkZTA2LTk4ODItNGRmZi1hNWI3LWYyMmM2Yjk5OTRmNCIKICAgR0lNUDpBUEk9IjIuMCIKICAgR0lNUDpQbGF0Zm9ybT0iTGludXgiCiAgIEdJTVA6VGltZVN0YW1wPSIxNzA1MDMzNDc5NzE1Nzg3IgogICBHSU1QOlZlcnNpb249IjIuMTAuMjIiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCI+CiAgIDxpcHRjRXh0OkxvY2F0aW9uQ3JlYXRlZD4KICAgIDxyZGY6QmFnLz4KICAgPC9pcHRjRXh0OkxvY2F0aW9uQ3JlYXRlZD4KICAgPGlwdGNFeHQ6TG9jYXRpb25TaG93bj4KICAgIDxyZGY6QmFnLz4KICAgPC9pcHRjRXh0OkxvY2F0aW9uU2hvd24+CiAgIDxpcHRjRXh0OkFydHdvcmtPck9iamVjdD4KICAgIDxyZGY6QmFnLz4KICAgPC9pcHRjRXh0OkFydHdvcmtPck9iamVjdD4KICAgPGlwdGNFeHQ6UmVnaXN0cnlJZD4KICAgIDxyZGY6QmFnLz4KICAgPC9pcHRjRXh0OlJlZ2lzdHJ5SWQ+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjBmMWIyMmUwLTAyZWMtNDI4MC1hODI2LTAxMTc1MDcxMjk5ZCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChMaW51eCkiCiAgICAgIHN0RXZ0OndoZW49Ii0wNjowMCIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3Y2Q0MTJhOS00ZmU1LTRmMmUtOGEyYy05ZGEwMGFhOWNmMWYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSItMDY6MDAiLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NzI4NDlkM2YtMzFhZS00YWFkLWJkN2MtMzQ3NzQ4YjJkMTYzIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKExpbnV4KSIKICAgICAgc3RFdnQ6d2hlbj0iLTA2OjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICAgPHBsdXM6SW1hZ2VTdXBwbGllcj4KICAgIDxyZGY6U2VxLz4KICAgPC9wbHVzOkltYWdlU3VwcGxpZXI+CiAgIDxwbHVzOkltYWdlQ3JlYXRvcj4KICAgIDxyZGY6U2VxLz4KICAgPC9wbHVzOkltYWdlQ3JlYXRvcj4KICAgPHBsdXM6Q29weXJpZ2h0T3duZXI+CiAgICA8cmRmOlNlcS8+CiAgIDwvcGx1czpDb3B5cmlnaHRPd25lcj4KICAgPHBsdXM6TGljZW5zb3I+CiAgICA8cmRmOlNlcS8+CiAgIDwvcGx1czpMaWNlbnNvcj4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PiuobvUAAAAGYktHRABOAE4ATvXgkQoAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfoAQwEGCdhbSCpAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAIABJREFUeNrtnVuMXGe159cqd9tOu3MFPCQZQjgEIiAgEpIRihMbJZCQhzgHBnTQETwMUsJBIhBGSOhIoAwQOY4BBydISHCEeEAizxCuJyIPyUGJhMQEhDQhcWy37bjttvuavrjbvdc81L6s77Kr9rVqV9X/LyXtrlvvqvr2b//X+ta3PiIIgiAIgiCoWvEwvIm9e/cKkcRvSUSImUmMNyjJDyYSYWIOb5DwsSwk4TP089q3CbFw+7lE9Ktf/pIxfCCot2oNxbsQIRGOYUUcUiXEmEjCZ2EOcRQxjkm4DSsiJlawkvB+FiIWTXnByIGgPmhsWIwicxtAzByShkPyhG5L2lDi+PEcO67YU7F2YqEDiwBITD7/BUEQHFY+gxXGecIRbkLXJAlcohAx+s/8RxI1Rr+1X0tCR5a8LmAFQQBWWX8V/2SiNqkikxXFhBLdzwZywkiShEWZLKYoAxaFgklIiHAQggCssi7L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`;
                                    var b64 = img;
                                    $( '.logo_image' ).src = b64;
                                    </script>
                            </div>
                            <div class="semaphore_name_and_desc">
                                <div class="semaphore_name">Semaphore</div>
                                <div class="semaphore_desc">Crowdfunding with bitcoin</div>
                            </div>
                        </div>
                    </a>
                    <div><button class="login_btn hidden">Log in</button></div>
                </div>
            </div>
            <div class="below_navbar">
                <div class="page_content">
                    <div class="welcome_page">
                        <p>
                            Welcome to Semaphore.
                        </p>
                        <div class="hidden">
                            <p>
                                Please use the stacker news sub below to find a list of crowdfunding projects, or make your own project.
                            </p>
                            <a href="https://stacker.news/" target="_blank" style="color: blue; text-decoration: underline; cursor: pointer;">
                                <h2>
                                    Find projects
                                </h2>
                            </a>
                        </div>
                        <h2 class="log_into_project" onclick="login()" style="color: blue; text-decoration: underline; cursor: pointer;">
                            View project you created or contributed to
                        </h2>
                        <h2 id="create_project_btn" class="create_project_btn" style="color: blue; text-decoration: underline; cursor: pointer;">
                            Create project
                        </h2>
                        <div class="create_project hidden">
                            <p style="font-weight: bold;">Enter project name</p>
                            <p><input class="project_nym"></p>
                            <p style="font-weight: bold;">Upload project pic<br>(1920x1080 recommended)</p>
                            <p><input class="project_pic" type="file" onchange="if ( this.files[ 0 ].size < 266240 ) {upload_data = [ this.files[ 0 ] ];} else {alert( 'File too large, make sure it is less than 260 kilobytes' ); this.value = null;}" /></p>
                            <p style="font-weight: bold;">Enter project description</p>
                            <p><textarea class="project_dsc"></textarea></p>
                            <p style="font-weight: bold;">Enter how much you want to raise in btc<br>e.g. 15.21212121</p>
                            <p><input class="project_gol"></p>
                            <p>Aka $<span class="project_gol_in_usd">0</span></p>
                            <p style="font-weight: bold;">Enter a bitcoin address where you want contributions to go</p>
                            <p><input class="project_add"></p>
                            <p style="font-weight: bold;">Enter a lightning address for second layer contributions (optional)</p>
                            <p><input class="project_lna"></p>
                            <p style="font-weight: bold;">Enter when you want your fundraiser to end</p>
                            <p><input type="date" name="project_end" id="project_end" class="project_end"></p>
                            <p><button class="submit_new_project">Submit</button></p>
                        </div>
                    </div>
                    <div class="project hidden"></div>
                </div>
            </div>
        </div>
        <script>
            $( '.project_gol' ).onchange = async () => {
                var num_of_btc = Number( $( '.project_gol' ).value );
                var num_in_sat = bitcoinToSats( num_of_btc );
                var amt_in_usd = await satsToDollars( num_in_sat );
                if ( isNaN( amt_in_usd ) || amt_in_usd < 0 ) amt_in_usd = 0;
                var pre_show = ( Math.round( amt_in_usd * 100 ) / 100 ).toLocaleString();
                var num_to_show = pre_show;
                if ( pre_show.includes( "." ) ) {
                    var part_before_dot = pre_show.substring( 0, pre_show.indexOf( "." ) );
                    var part_after_dot = pre_show.substring( pre_show.indexOf( "." ) + 1 );
                    part_after_dot = part_after_dot.padEnd( 2, "0" );
                    num_to_show = part_before_dot + "." + part_after_dot;
                }
                $( '.project_gol_in_usd' ).innerText = num_to_show;
            }
            $( '.project_gol' ).onkeyup = async () => {
                var num_of_btc = Number( $( '.project_gol' ).value );
                var num_in_sat = bitcoinToSats( num_of_btc );
                var amt_in_usd = await satsToDollars( num_in_sat );
                if ( isNaN( amt_in_usd ) || amt_in_usd < 0 ) amt_in_usd = 0;
                var pre_show = ( Math.round( amt_in_usd * 100 ) / 100 ).toLocaleString();
                var num_to_show = pre_show;
                if ( pre_show.includes( "." ) ) {
                    var part_before_dot = pre_show.substring( 0, pre_show.indexOf( "." ) );
                    var part_after_dot = pre_show.substring( pre_show.indexOf( "." ) + 1 );
                    part_after_dot = part_after_dot.padEnd( 2, "0" );
                    num_to_show = part_before_dot + "." + part_after_dot;
                }
                $( '.project_gol_in_usd' ).innerText = num_to_show;
            }
            $( '.create_project_btn' ).onclick = () => {
                $( '.create_project' ).classList.remove( "hidden" );
                location.href = "#create_project_btn";
            }
            $( '.project_nym' ).value = "";
            $( '.project_pic' ).value = null;
            $( '.project_dsc' ).value = "";
            $( '.project_gol' ).value = "";
            $( '.project_add' ).value = "";
            $( '.project_lna' ).value = "";
            $( '.project_end' ).value = "";
            $( '.submit_new_project' ).onclick = async () => {
                if ( $( '.project_lna' ).value ) {
                    var lnaddress = $( '.project_lna' ).value;
                    if ( lnaddress.startsWith( " " ) ) return showModal( `Your lightning address started with a space character, which is invalid. Please check it and try again` );
                    var split_lna = lnaddress.split( "@" );
                    var domain = split_lna[ 1 ];
                    var username = split_lna[ 0 ];
                    var url = `https://${domain}/.well-known/lnurlp/${username}`;
                    try {
                        var ln_info = await getData( url );
                        ln_info = JSON.parse( ln_info );
                    } catch( e ) {
                        return showModal( `<p>The lightning address you provided does not exist or the service provider's server (${domain}) does not support standard http requests, probably due to a CORS error on their server, or due to being hosted as a tor hidden service. Please pick a different lightning address and try again.</p><p>If you think the server (${domain}) may be at fault, consider filing a complaint with them so they fix their server or offer a non-tor option. Or, if you think you received this error message erroneously, open an issue on Semaphore's github page.</p>` );
                    }
                    var minSendable = ln_info[ "minSendable" ];
                    var callback = ln_info[ "callback" ];
                    var second_url = `${callback}?amount=${minSendable}`;
                    var has_verify = false;
                    try {
                        var invoice_info = await getData( second_url );
                        invoice_info = JSON.parse( invoice_info );
                        if ( "verify" in invoice_info ) has_verify = true;
                        var invoice = invoice_info[ "pr" ];
                        if ( !invoice ) throw "didn't work";
                    } catch( e ) {
                        var invoice = "didn't work";
                    }
                    if ( invoice == "didn't work" ) return showModal( `The server of the lightning address you provided (${domain}) doesn't support standard HTTPS Get requests, probably due to a CORS error or due to being an onion address. Please pick a different lightning address provider and try again, and maybe file a complaint with them so they fix their server or offer a non-tor option.` );
                }
                setTimeout( () => {upload_data = [];$( '.project_pic' ).value = null;}, 500 );
                showModal( `
                    <p>Creating your project, please wait</p>
                    <h2>Progress bar <span id="goal" style="font-size: .8em; font-weight: normal;"></span></h2>
                    <div class="progressOutline" style="height: 2em; border: 1px solid grey; border-radius: 25px; overflow: hidden;">
                        <div class="progressBar" style="height: 2em; background-color: #61eb34; width: 0%; transition: width 1s;">
                        </div>
                    </div>
                ` );
                if ( !isValidAddress( $( '.project_add' ).value ) ) return showModal( `Try again with a valid bitcoin address` );
                //TODO: uncomment the line below
                // if ( $( '.project_add' ).value.startsWith( "t" ) || $( '.project_add' ).value.startsWith( "r" ) || $( '.project_add' ).value.startsWith( "m" ) || $( '.project_add' ).value.startsWith( "n" ) || $( '.project_add' ).value.startsWith( "2" ) ) return showModal( `Try again with a mainnet bitcoin address` );
                if ( isNaN( $( '.project_gol' ).value ) ) return showModal( `Try again with a valid goal` );
                if ( Number( $( '.project_gol' ).value ) < 0.001 ) return showModal( `You picked a goal below the minimum of 0.001 btc. Please try again` );
                if ( !$( '.project_end' ).value ) return showModal( `Try again with a valid end date` );
                var file = upload_data[ 0 ];
                if ( !file || !( file.constructor === File ) ) return showModal( `You forgot to select a file to upload as your project picture, please try again` );
                var b64_1 = await nostr_image_host.encodeBase64( file );
                upload_data = [];
                var end_in_seconds = Math.floor( new Date( $( '.project_end' ).value ).getTime() / 1000 );
                var now = Math.floor( Date.now() / 1000 );
                var seconds_til_end = end_in_seconds - now;
                if ( seconds_til_end < 60 * 60 * 24 * 7 ) return showModal( `Your end date must be at least 1 week in the future, please try again` );
                var blocks_til_end = Math.ceil( seconds_til_end / 600 );
                var current_blockheight = await getBlockheight( "" );
                var end_block = current_blockheight + blocks_til_end;
                var project = {
                    project_nym: $( '.project_nym' ).value,
                    project_dsc: $( '.project_dsc' ).value,
                    project_gol: Number( $( '.project_gol' ).value ) * 100000000,
                    project_add: $( '.project_add' ).value,
                    project_lna: $( '.project_lna' ).value,
                    has_verify,
                    project_end: end_block,
                    project_key: btc_pub,
                }
                var b64_2 = btoa( JSON.stringify( project ) );
                var fulltext = b64_1 + "|---|" + b64_2;
                socket = new WebSocket( relay );
                socket.addEventListener('open', async function( e ) {
                    var array = fulltext.match(/.{1,4000}/g);
                    var privKey = nostr_image_host.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    var pubKey = nobleSecp256k1.getPublicKey( privKey, true ).substring( 2 );
                    var i; for ( i=0; i<array.length; i++ ) {
                        var note = array[ i ];
                        var part = i + 1;
                        var whole = array.length;
                        var id = await nostr_image_host.sendNoteAndReturnId( note, part, whole, socket, privKey, pubKey );
                        var sprj = nostr_image_host.hexToBech32( "sprj", id + nostr_image_host.textToHex( relay ) );
                        var percent = Number( ( ( part / whole ) * 100 ).toFixed( 2 ) );
                        if ( $( '.progressBar' ) ) $( '.progressBar' ).style.width = String( percent ) + "%";
                        if ( percent > 99 ) await nostr_image_host.waitSomeSeconds( 1 );
                        var url = window.location.href;
                        if ( url.includes( "#" ) ) url = url.substring( 0, url.indexOf( "#" ) );
                        var q_char = url.includes( "?" ) ? "&":"?";
                        url = url + `${q_char}fundraiser=${sprj}`;
                        var backup_file_contents = {
                            privkey: btc_sec,
                            fundraiser_id: sprj,
                        }
                        var fileName = `semaphore_fundraiser_${sprj}_backup.json`;
                        if ( percent == 100 ) showModal( `<p>First, download and store <span style="color: blue; text-decoration: underline; cursor: pointer;" onclick='saveData( ${JSON.stringify( backup_file_contents )}, "${fileName}" );'>your backup file</span>. You can only log in to claim your funds with this backup file.</p><p>Second, <a href="${url}" target="_blank" style="color: blue; text-decoration: underline; cursor: pointer;">here</a> is a link to your project. Have fun!</p>` );
                        await nostr_image_host.waitSomeSeconds( 2 );
                    }
                    socket.close();
                });
            }
            $( '.login_btn' ).onclick = login;
            if ( $_GET[ "fundraiser" ] ) loadFundraiser();
            else setTimeout( async () => sessionStorage[ "btc_price" ] = await getBitcoinPrice(), 100 );
        </script>
        <div class="black-bg hidden"></div>
        <div class="modal hidden"></div>
    </body>
</html>
